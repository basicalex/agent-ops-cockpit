#!/usr/bin/env bash
set -euo pipefail

usage() {
  cat <<'EOF'
Usage: aoc-session-watch <root-tag> [layout-path] [root-file] [star-file]

Monitors a Zellij session "aoc-<root-tag>".
When the session becomes detached (0 clients), it is immediately destroyed
to free resources.
EOF
}

if [[ $# -lt 1 ]]; then
  usage >&2
  exit 1
fi

root_tag="$1"
session_name="aoc-${root_tag}"
interval_secs="${AOC_IDLE_INTERVAL:-5}"

# Wait for session to appear
wait_for_session() {
  local retries=30 # 30 * 0.5s = 15s timeout
  while (( retries > 0 )); do
    if zellij list-sessions --short 2>/dev/null | grep -Fxq "$session_name"; then
      return 0
    fi
    sleep 0.5
    ((retries--))
  done
  return 1
}

if ! wait_for_session; then
  # Session never appeared or we missed it (maybe user cancelled launch)
  exit 0
fi

# Monitor loop
consecutive_idle=0
max_idle=3

while true; do
  # Check if session still exists
  if ! zellij list-sessions --short 2>/dev/null | grep -Fxq "$session_name"; then
    exit 0
  fi

  # Check client count with a timeout to avoid hanging on slow sessions
  # Use 'timeout' to ensure we don't block forever
  if clients_raw=$(timeout 2s zellij action list-clients 2>/dev/null); then
    # Filter out empty lines/whitespace
    trimmed_clients="${clients_raw//[[:space:]]/}"
    if [[ -z "$trimmed_clients" ]]; then
      ((consecutive_idle++))
    else
      consecutive_idle=0
    fi
  else
    # Command failed or timed out - assume active to be safe
    consecutive_idle=0
  fi

  if (( consecutive_idle >= max_idle )); then
    # No clients connected for several consecutive checks - destroy to free resources
    # Double check one last time with list-sessions which is less prone to hanging
    if ! zellij list-sessions 2>/dev/null | grep -F "$session_name" | grep -iq "attached"; then
       zellij delete-session "$session_name" --force >/dev/null 2>&1 || true
       exit 0
    fi
    consecutive_idle=0
  fi

  sleep "$interval_secs"
done
