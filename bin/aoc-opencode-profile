#!/usr/bin/env bash
set -euo pipefail

usage() {
  cat <<'EOF'
Usage: aoc-opencode-profile <command> [args...]

Manage OpenCode profile paths for sandbox-first OmO integration.

Commands:
  resolve [profile]                Resolve profile path (no profile = active path)
  init [profile]                   Initialize profile idempotently (default: sandbox)
  promote <source> <target> [--yes]
                                   Promote source profile into target with backup
  rollback <target> [snapshot] [--yes]
                                   Restore target profile from snapshot (latest by default)
  list-backups <target>            List snapshots for a target profile (newest first)
  help                             Show this help

Profiles:
  - main (alias: default)
  - sandbox
  - custom profile names (a-z, 0-9, ., _, -)

Environment:
  OPENCODE_CONFIG_DIR             Active profile override for `resolve` (no args)
  AOC_OPENCODE_PROFILE_ROOT       Root for sandbox/custom profiles
  AOC_OPENCODE_MAIN_PROFILE       Override path for main profile
  AOC_OPENCODE_PROFILE_BACKUP_ROOT
                                  Override backup root path
  AOC_OPENCODE_PROFILE_YES=1      Non-interactive confirmation for main promote/rollback
EOF
}

die() {
  echo "Error: $*" >&2
  exit 1
}

to_lower() {
  printf '%s' "$1" | tr '[:upper:]' '[:lower:]'
}

is_truthy() {
  local value="${1:-}"
  value="$(to_lower "$value")"
  case "$value" in
    1|true|yes|on)
      return 0
      ;;
    *)
      return 1
      ;;
  esac
}

config_home() {
  printf '%s' "${XDG_CONFIG_HOME:-$HOME/.config}"
}

state_home() {
  printf '%s' "${XDG_STATE_HOME:-$HOME/.local/state}"
}

main_profile_path() {
  if [[ -n "${AOC_OPENCODE_MAIN_PROFILE:-}" ]]; then
    printf '%s' "$AOC_OPENCODE_MAIN_PROFILE"
    return
  fi
  printf '%s/opencode' "$(config_home)"
}

profile_root_path() {
  if [[ -n "${AOC_OPENCODE_PROFILE_ROOT:-}" ]]; then
    printf '%s' "$AOC_OPENCODE_PROFILE_ROOT"
    return
  fi
  printf '%s/aoc/opencode/profiles' "$(config_home)"
}

backup_root_path() {
  if [[ -n "${AOC_OPENCODE_PROFILE_BACKUP_ROOT:-}" ]]; then
    printf '%s' "$AOC_OPENCODE_PROFILE_BACKUP_ROOT"
    return
  fi
  printf '%s/aoc/opencode-profile-backups' "$(state_home)"
}

is_valid_profile_name() {
  local name="$1"
  [[ "$name" =~ ^[a-z0-9][a-z0-9._-]*$ ]] || return 1
  [[ "$name" != "." && "$name" != ".." ]]
}

normalize_profile_name() {
  local name="${1:-}"
  if [[ -z "$name" ]]; then
    die "profile name required"
  fi

  name="$(to_lower "$name")"
  case "$name" in
    default)
      name="main"
      ;;
  esac

  printf '%s' "$name"
}

resolve_named_profile_path() {
  local name
  name="$(normalize_profile_name "$1")"

  case "$name" in
    main)
      main_profile_path
      return
      ;;
    sandbox)
      printf '%s/sandbox' "$(profile_root_path)"
      return
      ;;
    *)
      if ! is_valid_profile_name "$name"; then
        die "invalid profile name: '$name'"
      fi
      printf '%s/%s' "$(profile_root_path)" "$name"
      return
      ;;
  esac
}

resolve_active_profile_path() {
  if [[ -n "${OPENCODE_CONFIG_DIR:-}" ]]; then
    printf '%s' "$OPENCODE_CONFIG_DIR"
    return
  fi
  main_profile_path
}

assert_managed_path() {
  local target="$1"
  local main_path root_path

  [[ -n "$target" ]] || die "refusing empty path"
  [[ "$target" == /* ]] || die "refusing non-absolute path: $target"

  main_path="$(main_profile_path)"
  root_path="$(profile_root_path)"

  case "$target" in
    "$main_path"|"$root_path"/*)
      ;;
    *)
      die "refusing unmanaged path: $target"
      ;;
  esac

  case "$target" in
    /|"$HOME"|"$(config_home)"|"$(state_home)")
      die "refusing unsafe path: $target"
      ;;
  esac
}

copy_dir_contents() {
  local source_dir="$1"
  local dest_dir="$2"

  [[ -d "$source_dir" ]] || die "source directory does not exist: $source_dir"
  mkdir -p "$dest_dir"
  cp -a "$source_dir"/. "$dest_dir"/
}

ensure_main_confirmation() {
  local operation="$1"
  local target_name="$2"

  if [[ "$target_name" != "main" ]]; then
    return
  fi

  if is_truthy "${AOC_OPENCODE_PROFILE_YES:-0}"; then
    return
  fi

  if [[ ! -t 0 ]]; then
    die "refusing to ${operation} main profile without --yes (or AOC_OPENCODE_PROFILE_YES=1)"
  fi

  local answer=""
  printf 'About to %s MAIN profile. Continue? [y/N]: ' "$operation" >&2
  read -r answer
  answer="$(to_lower "$answer")"
  case "$answer" in
    y|yes)
      return
      ;;
    *)
      die "operation cancelled"
      ;;
  esac
}

create_snapshot() {
  local target_name="$1"
  local target_path="$2"
  local reason="$3"
  local target_backup_root ts snapshot_dir idx data_dir meta_file
  local state="absent"

  target_backup_root="$(backup_root_path)/$target_name"
  mkdir -p "$target_backup_root"

  ts="$(date -u '+%Y%m%d-%H%M%SZ')"
  snapshot_dir="$target_backup_root/$ts"
  idx=0
  while [[ -e "$snapshot_dir" ]]; do
    idx=$((idx + 1))
    snapshot_dir="$target_backup_root/${ts}-$idx"
  done

  data_dir="$snapshot_dir/data"
  meta_file="$snapshot_dir/meta"
  mkdir -p "$data_dir"

  if [[ -d "$target_path" ]]; then
    copy_dir_contents "$target_path" "$data_dir"
    state="present"
  fi

  cat > "$meta_file" <<EOF
target_name=$target_name
target_path=$target_path
state=$state
reason=$reason
created_at=$(date -u '+%Y-%m-%dT%H:%M:%SZ')
EOF

  printf '%s' "$snapshot_dir"
}

latest_snapshot_for_target() {
  local target_name="$1"
  local target_backup_root latest=""

  target_backup_root="$(backup_root_path)/$target_name"
  if [[ ! -d "$target_backup_root" ]]; then
    return
  fi

  shopt -s nullglob
  local candidate=""
  for candidate in "$target_backup_root"/*; do
    [[ -d "$candidate" ]] || continue
    latest="$candidate"
  done
  shopt -u nullglob

  printf '%s' "$latest"
}

read_meta_value() {
  local meta_file="$1"
  local key="$2"
  local line=""

  [[ -f "$meta_file" ]] || return 1

  while IFS= read -r line; do
    case "$line" in
      "$key="*)
        printf '%s' "${line#*=}"
        return 0
        ;;
    esac
  done < "$meta_file"

  return 1
}

restore_snapshot() {
  local snapshot_dir="$1"
  local target_path="$2"
  local data_dir="$snapshot_dir/data"
  local meta_file="$snapshot_dir/meta"
  local state="present"
  local tmp_root

  state="$(read_meta_value "$meta_file" "state" || printf 'present')"

  assert_managed_path "$target_path"
  if [[ "$state" == "absent" ]]; then
    rm -rf "$target_path"
    return
  fi

  [[ -d "$data_dir" ]] || die "snapshot data missing: $data_dir"

  tmp_root="$(mktemp -d "${TMPDIR:-/tmp}/aoc-opencode-profile-restore.XXXXXX")"
  mkdir -p "$tmp_root/new-profile"
  copy_dir_contents "$data_dir" "$tmp_root/new-profile"

  rm -rf "$target_path"
  mkdir -p "$(dirname "$target_path")"
  mv "$tmp_root/new-profile" "$target_path"
  rm -rf "$tmp_root"
}

parse_yes_flag() {
  YES_FLAG=0
  REMAINING_ARGS=()

  local arg=""
  for arg in "$@"; do
    case "$arg" in
      --yes|-y)
        YES_FLAG=1
        ;;
      *)
        REMAINING_ARGS+=("$arg")
        ;;
    esac
  done
}

resolve_snapshot_argument() {
  local target_name="$1"
  local snapshot_spec="${2:-}"
  local target_backup_root snapshot_dir

  target_backup_root="$(backup_root_path)/$target_name"
  [[ -d "$target_backup_root" ]] || die "no backups found for profile '$target_name'"

  if [[ -n "$snapshot_spec" ]]; then
    [[ "$snapshot_spec" != */* ]] || die "snapshot id must be a local id, not a path"
    snapshot_dir="$target_backup_root/$snapshot_spec"
    [[ -d "$snapshot_dir" ]] || die "snapshot not found: $snapshot_spec"
    printf '%s' "$snapshot_dir"
    return
  fi

  snapshot_dir="$(latest_snapshot_for_target "$target_name")"
  [[ -n "$snapshot_dir" ]] || die "no backups found for profile '$target_name'"
  printf '%s' "$snapshot_dir"
}

command_resolve() {
  if (($# > 1)); then
    die "usage: aoc-opencode-profile resolve [profile]"
  fi

  if (($# == 0)); then
    resolve_active_profile_path
    printf '\n'
    return
  fi

  resolve_named_profile_path "$1"
  printf '\n'
}

command_init() {
  if (($# > 1)); then
    die "usage: aoc-opencode-profile init [profile]"
  fi

  local profile_name="${1:-sandbox}"
  local profile_path
  profile_path="$(resolve_named_profile_path "$profile_name")"

  assert_managed_path "$profile_path"
  mkdir -p "$profile_path"

  local opencode_json="$profile_path/opencode.json"
  if [[ ! -f "$opencode_json" ]]; then
    printf '{}\n' > "$opencode_json"
  fi

  printf '%s\n' "$profile_path"
}

command_promote() {
  parse_yes_flag "$@"
  set -- "${REMAINING_ARGS[@]}"
  if (($# != 2)); then
    die "usage: aoc-opencode-profile promote <source> <target> [--yes]"
  fi

  local source_name target_name source_path target_path snapshot_dir tmp_root
  source_name="$(normalize_profile_name "$1")"
  target_name="$(normalize_profile_name "$2")"

  source_path="$(resolve_named_profile_path "$source_name")"
  target_path="$(resolve_named_profile_path "$target_name")"

  assert_managed_path "$source_path"
  assert_managed_path "$target_path"

  [[ "$source_path" != "$target_path" ]] || die "source and target profiles are the same"
  [[ -d "$source_path" ]] || die "source profile does not exist: $source_name ($source_path)"

  if ((YES_FLAG == 1)); then
    AOC_OPENCODE_PROFILE_YES=1
  fi
  ensure_main_confirmation "promote into" "$target_name"

  snapshot_dir="$(create_snapshot "$target_name" "$target_path" "promote:$source_name")"

  tmp_root="$(mktemp -d "${TMPDIR:-/tmp}/aoc-opencode-profile-promote.XXXXXX")"
  mkdir -p "$tmp_root/new-profile"
  copy_dir_contents "$source_path" "$tmp_root/new-profile"

  rm -rf "$target_path"
  mkdir -p "$(dirname "$target_path")"
  mv "$tmp_root/new-profile" "$target_path"
  rm -rf "$tmp_root"

  echo "Snapshot created: $(basename "$snapshot_dir")" >&2
  printf '%s\n' "$target_path"
}

command_rollback() {
  parse_yes_flag "$@"
  set -- "${REMAINING_ARGS[@]}"
  if (($# < 1 || $# > 2)); then
    die "usage: aoc-opencode-profile rollback <target> [snapshot] [--yes]"
  fi

  local target_name target_path requested_snapshot snapshot_dir guard_snapshot
  target_name="$(normalize_profile_name "$1")"
  requested_snapshot="${2:-}"
  target_path="$(resolve_named_profile_path "$target_name")"

  assert_managed_path "$target_path"

  if ((YES_FLAG == 1)); then
    AOC_OPENCODE_PROFILE_YES=1
  fi
  ensure_main_confirmation "rollback" "$target_name"

  snapshot_dir="$(resolve_snapshot_argument "$target_name" "$requested_snapshot")"
  guard_snapshot="$(create_snapshot "$target_name" "$target_path" "pre-rollback")"
  restore_snapshot "$snapshot_dir" "$target_path"

  echo "Rollback source snapshot: $(basename "$snapshot_dir")" >&2
  echo "Rollback guard snapshot: $(basename "$guard_snapshot")" >&2
  printf '%s\n' "$target_path"
}

command_list_backups() {
  if (($# != 1)); then
    die "usage: aoc-opencode-profile list-backups <target>"
  fi

  local target_name target_backup_root entries=() i
  target_name="$(normalize_profile_name "$1")"
  target_backup_root="$(backup_root_path)/$target_name"

  if [[ ! -d "$target_backup_root" ]]; then
    return
  fi

  shopt -s nullglob
  local candidate=""
  for candidate in "$target_backup_root"/*; do
    [[ -d "$candidate" ]] || continue
    entries+=("$(basename "$candidate")")
  done
  shopt -u nullglob

  for ((i=${#entries[@]}-1; i>=0; i--)); do
    printf '%s\n' "${entries[$i]}"
  done
}

main() {
  local cmd="${1:-help}"
  shift || true

  case "$cmd" in
    resolve)
      command_resolve "$@"
      ;;
    init)
      command_init "$@"
      ;;
    promote)
      command_promote "$@"
      ;;
    rollback)
      command_rollback "$@"
      ;;
    list-backups)
      command_list_backups "$@"
      ;;
    help|-h|--help)
      usage
      ;;
    *)
      usage
      die "unknown command: $cmd"
      ;;
  esac
}

main "$@"
