#!/usr/bin/env bash
set -euo pipefail

# AOC Initialization Script
# Usage: aoc-init [path]
#
# This script standardizes a project for the Agent Ops Cockpit.
# It is IDEMPOTENT: safe to run multiple times. It respects existing data.

project_root="${1:-$PWD}"
aoc_dir="$project_root/.aoc"
gemini_dir="$project_root/.gemini"
task_dir="$project_root/.taskmaster"
global_task_conf="$HOME/.taskmaster/config.json"
aoc_config_dir="${XDG_CONFIG_HOME:-$HOME/.config}/aoc"
script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

log() { echo ">> $1"; }
warn() { echo "!! $1"; }

positive_int_or_default() {
  local candidate="$1"
  local fallback="$2"
  if [[ "$candidate" =~ ^[0-9]+$ ]] && (( candidate > 0 )); then
    printf '%s' "$candidate"
  else
    printf '%s' "$fallback"
  fi
}

write_aoc_agents_contract() {
  local target_file="$1"
  cat <<'EOF' > "$target_file"
# AOC Architecture & Agent Guidelines

This file defines the always-on rules for agents in this repo. Procedural playbooks live in AOC skills.

## Always-on rules
- Use `.aoc/context.md` for orientation; run `aoc-init` if it is missing or stale.
- **DO NOT manually read these files** - use the Bash tool to run CLI commands instead (see below).
- Run AOC commands via Bash tool - do NOT use Read tool for `.aoc/memory.md`, `.aoc/stm/current.md`, or `.taskmaster/tasks/tasks.json`.
- RTK routing is default-on for new AOC projects (`.aoc/rtk.toml` mode=`on`); existing explicit mode=`off` is preserved.
- RTK exists to improve context health: allowlisted noisy commands are condensed for better signal density, with fail-open native fallback.

## Low-Token Default Mode
- Keep responses concise by default; do not print full files or raw logs unless explicitly requested.
- Start with the smallest viable step; use narrow, path-scoped searches before broad scans.
- Read files in bounded chunks and avoid rereading unchanged large files.
- Summarize command/tool output with actionable lines only (key errors, next actions).
- Run targeted checks/tests first; run full-suite commands only when required.
- If targeted inspection fails, escalate scope gradually and state why.
- Use fresh sessions after major milestones or context drift to reduce replay overhead.
- For narrow diagnostics/Q&A, use at most 3 tool calls before first answer; ask before broader escalation.
- Do not open/read image binaries unless the user explicitly asks to view/open one now.
- Use one narrow diagnostic path first; avoid retry spray with variant commands unless first attempt fails.

## AOC CLI Commands (run via Bash tool - NOT Read tool)
These commands are in PATH and work without loading any skill:

**Memory:**
- `aoc-mem read` - read persistent memory
- `aoc-mem add "decision"` - record architectural decision

**Short-Term Memory (STM):**
- `aoc-stm` - print current draft (shortcut for `aoc-stm read-current`)
- `aoc-stm handoff` - archive current draft and print handoff snapshot
- `aoc-stm resume` - print archived handoff snapshot (latest by default)
- `aoc-stm read` - read latest archived snapshot
- `aoc-stm archive` - archive current draft
- `aoc-stm add "note"` - add to current draft
- `aoc-stm edit` - edit current draft in editor

**Tasks:**
- `tm list` - list tasks (alias for `aoc-task`)
- `tm add "Task name"` - add new task
- `tm tag current` - print effective active tag
- `tm tag prd show` - show PRD linked to active tag
- `aoc-task tag prd show --tag <tag>` - show PRD linked to a specific tag
- `tm --tm-root <path> ...` - run Taskmaster commands against another project
- `tm` - open Taskmaster TUI

**Other:**
- `aoc-init` - initialize/repair AOC files
- `aoc-mem search "query"` - search memory
- `aoc-rtk status` - check RTK routing status
- `aoc-rtk enable|disable` - toggle RTK routing mode
- `aoc-rtk doctor` - run RTK diagnostics
- `aoc-rtk install --auto` - auto-fetch and install pinned RTK binary

## Core files
- `.aoc/context.md`: auto-generated project snapshot.
- `.aoc/rtk.toml`: project-local RTK routing policy and install contract.
- `.aoc/layouts/`: project-shared Zellij layouts for AOC (`*.kdl`).
- `.taskmaster/docs/prds/`: PRD documents linked to tags and tasks.
- Tag PRD defaults are linked via tag `aocPrd`; resolve with `aoc-task tag prd show --tag <tag>`.
- Task PRD overrides are linked via task `aocPrd`; resolve with `aoc-task prd show <id> --tag <tag>`.
- Effective precedence is task PRD override -> tag PRD default.
- Keep task PRDs in git: `.taskmaster/docs/prds/**` should always be tracked.
- Keep AOC/task state in git: `.aoc/**`, `.taskmaster/**`, and `.pi/**` should not be ignored.

## Task Management
- `.taskmaster/tasks/tasks.json` is task state; use the Taskmaster TUI, `aoc-task`, or `tm` (alias for `aoc-task`). Do not edit the file directly.
- Record major decisions and constraints in memory (`aoc-mem add "..."`).

## Skills (load when needed)
- `aoc-workflow`: standard project workflow.
- `teach-workflow`: guided teach-mode scans, dives, and local insight logging.
- `rlm-analysis`: large codebase analysis flow.
- `prd-dev`: draft the Taskmaster PRD.
- `prd-intake`: parse a project PRD into initial task sets.
- `prd-align`: align tasks with the PRD.
- `tag-align`: normalize task tags and dependencies.
- `task-breakdown`: expand a task into clear subtasks.
- `task-checker`: verify implementation vs. testStrategy.
- `release-notes`: draft changelog and release notes.
- `skill-creator`: create or update AOC skills.
- `zellij-theme-ops`: create and manage global Zellij themes.
- `tm-cc`: cross-project Taskmaster control with explicit tm root targeting.

Note: `aoc-mem`, `aoc-stm`, and `tm` are basic CLI commands (see above) - no skill needed.
EOF
}

write_pi_low_token_prompt() {
  local target_file="$1"
  cat <<'EOF' > "$target_file"
# PI Low-Token Mode (AOC Default)

Apply these defaults unless the user asks for higher detail.

- Keep replies concise and actionable (default: <= 8 bullets).
- Start with direct path guesses before searching. Example: if asked about screenshot tool, check `.pi/extensions/latest-screenshot.ts` first.
- Avoid broad scans by default. Do NOT run `tm list`, `git status`, or repo-wide `rg` unless the user asks or a targeted check fails.
- Use the fewest tool calls needed. For simple locate/explain requests, limit to 1-3 focused reads.
- Hard budget before first answer: at most 3 tool calls unless the first attempt fails.
- If unresolved after 3 calls, ask before broader escalation.
- For "does tool X work" checks, do only: (1) read tool file/settings, (2) run the tool once, then report.
- Read only minimal slices first; avoid rereading unchanged large files.
- Never dump large raw output. Summarize key lines and include file paths only.
- Do not read/open image files unless the user explicitly asks to view/open the image now.
- Run targeted tests/checks first; escalate to full-suite only when required.
- If you must widen scope, state why in one short line and widen one step at a time.
EOF
}

ensure_agents_contract() {
  local agents_file="$1"

  if [[ ! -f "$agents_file" ]]; then
    log "Creating AGENTS.md..."
    write_aoc_agents_contract "$agents_file"
    return
  fi

  if grep -Eq "AOC Architecture & Agent Guidelines|Agent Ops Cockpit \(AOC\)" "$agents_file"; then
    local tmp_agents
    tmp_agents="$(mktemp)"
    write_aoc_agents_contract "$tmp_agents"
    if ! cmp -s "$tmp_agents" "$agents_file"; then
      cp "$tmp_agents" "$agents_file"
      log "Updated AGENTS.md to latest AOC contract."
    else
      log "AGENTS.md already up to date."
    fi
    rm -f "$tmp_agents"
    return
  fi

  if grep -Fq "## Agent Ops Cockpit (AOC)" "$agents_file"; then
    log "Existing AGENTS.md already includes an AOC section. Preserving."
    return
  fi

  log "Appending AOC command guidance to existing AGENTS.md..."
  cat <<'EOF' >> "$agents_file"

## Agent Ops Cockpit (AOC)
Use the AOC tools for context, memory, and tasks in this repo.

- **Context:** `.aoc/context.md` (auto-generated project map)
- **Memory:** use `aoc-mem read/search/add` via Bash tool (do not edit `.aoc/memory.md` directly)
- **Short-term memory:** use `aoc-stm` (draft), `aoc-stm handoff` (seal), and `aoc-stm resume`/`aoc-stm read` (resume) via Bash tool (do not read `.aoc/stm/current.md` directly)
- **Tasks:** use `tm` or `aoc-task` via Bash tool (do not edit `.taskmaster/tasks/tasks.json` directly)
- **Task PRDs:** tag-level defaults + task-level overrides via `aocPrd` (resolve with `aoc-task tag prd show --tag <tag>` and `aoc-task prd show <id> --tag <tag>`)
- **RTK routing (default-on for new AOC repos):** allowlisted commands route via RTK in AOC panes; manage with `aoc-rtk status|enable|disable|doctor|install --auto` and `.aoc/rtk.toml`

If AOC files are missing or stale, run `aoc-init` at the repo root.
EOF
}

write_default_rtk_config() {
  local target_file="$1"
  cat <<'EOF' > "$target_file"
# AOC RTK routing config (project-local, seeded by aoc-init)
# mode: off|on
mode = "on"
fail_open = true
# gain_mode: double-dash|positional
gain_mode = "double-dash"
binary = "rtk"
allowlist = [
  "git status",
  "git diff",
  "git log",
  "git show",
  "git branch",
  "git rev-parse",
  "rg",
  "fd",
  "ls",
  "du",
  "wc",
  "cat",
  "head",
  "tail",
  "pytest",
  "cargo test",
  "npm test",
  "pnpm test",
  "bun test",
]
denylist = [
  "git add",
  "git commit",
  "git checkout",
  "git switch",
  "git merge",
  "git rebase",
  "git push",
  "git reset --hard",
  "git clean -fd",
  "rm -rf",
  "sudo",
  "ssh",
  "scp",
]
# Install contract: pinned URL + pinned sha256
install_url = ""
install_sha256 = ""
EOF
}

read_rtk_mode() {
  local rtk_file="$1"
  if ! command -v python3 >/dev/null 2>&1; then
    return
  fi

  python3 - "$rtk_file" <<'PY'
import sys
from pathlib import Path

try:
    import tomllib
except Exception:
    tomllib = None

path = Path(sys.argv[1])
if tomllib is None or not path.exists():
    raise SystemExit(0)

mode = ""
try:
    data = tomllib.loads(path.read_text(encoding="utf-8"))
    mode = str(data.get("mode", "")).strip().lower()
except Exception:
    mode = ""

if mode in {"on", "off"}:
    print(mode)
PY
}

ensure_rtk_config() {
  local rtk_file="$aoc_dir/rtk.toml"
  if [[ ! -f "$rtk_file" ]]; then
    write_default_rtk_config "$rtk_file"
    log "Seeded RTK routing config ($rtk_file, mode=on default)."
  else
    local existing_mode=""
    existing_mode="$(read_rtk_mode "$rtk_file" || true)"
    if [[ "$existing_mode" == "off" ]]; then
      log "RTK routing config exists with mode=off ($rtk_file). Preserving explicit disable."
    elif [[ "$existing_mode" == "on" ]]; then
      log "RTK routing config exists with mode=on ($rtk_file). Preserving."
    else
      log "RTK routing config exists ($rtk_file). Preserving."
    fi
  fi
}

ensure_git_tracking_policy() {
  local ignore_file="$project_root/.gitignore"
  local changed=0
  local line=""

  if [[ ! -f "$ignore_file" ]]; then
    log "Creating .gitignore..."
    : > "$ignore_file"
  fi

  if [[ -s "$ignore_file" ]]; then
    local last_char=""
    last_char="$(tail -c 1 "$ignore_file" 2>/dev/null || true)"
    if [[ "$last_char" != $'\n' ]]; then
      printf '\n' >> "$ignore_file"
    fi
  fi

  local rules=(
    "# AOC tracking policy (managed by aoc-init)"
    "!/.aoc/"
    "!/.aoc/**"
    "!/.taskmaster/"
    "!/.taskmaster/**"
    "!/.pi/"
    "!/.pi/**"
  )

  for line in "${rules[@]}"; do
    if ! grep -Fqx "$line" "$ignore_file"; then
      printf '%s\n' "$line" >> "$ignore_file"
      changed=1
    fi
  done

  if [[ "$changed" == "1" ]]; then
    log "Updated .gitignore to keep .aoc/, .taskmaster/, and .pi/ tracked."
  else
    log ".gitignore already keeps .aoc/, .taskmaster/, and .pi/ tracked."
  fi
}

# 1. Setup Context & Memory (.aoc/)
setup_memory() {
  # Migration Logic
  if [[ -d "$gemini_dir" && ! -d "$aoc_dir" ]]; then
    log "Migrating .gemini/ to .aoc/..."
    mv "$gemini_dir" "$aoc_dir"
    if [[ -f "$aoc_dir/GEMINI.md" ]]; then
      mv "$aoc_dir/GEMINI.md" "$aoc_dir/context.md"
    fi
  fi

  if [[ ! -d "$aoc_dir" ]]; then
    log "Creating .aoc/ directory..."
    mkdir -p "$aoc_dir"
  fi

  # Memory File
  local mem_file="$aoc_dir/memory.md"
  if [[ ! -f "$mem_file" ]]; then
    log "Initializing empty memory ($mem_file)..."
    cat <<EOF > "$mem_file"
# Agent Memory for Project: $(basename "$project_root")
This file contains persistent context, decisions, and knowledge for the AI agent.
Agents should read this to understand project history and append new decisions here.

## Core Decisions
EOF
  else
    log "Memory file exists ($mem_file). Skipping."
  fi

  # Short-term memory workspace
  local stm_dir="$aoc_dir/stm"
  local stm_current="$stm_dir/current.md"
  local stm_archive="$stm_dir/archive"
  mkdir -p "$stm_archive"
  if [[ ! -f "$stm_current" ]]; then
    log "Initializing short-term memory ($stm_current)..."
    : > "$stm_current"
  else
    log "Short-term memory exists ($stm_current). Preserving."
  fi

  # Shared project layouts
  local layouts_dir="$aoc_dir/layouts"
  if [[ ! -d "$layouts_dir" ]]; then
    log "Creating shared layouts directory ($layouts_dir)..."
    mkdir -p "$layouts_dir"
  fi

  # AGENTS.md (project-level agent contract)
  local agents_file="$project_root/AGENTS.md"
  ensure_agents_contract "$agents_file"

  ensure_rtk_config

  # PI default prompt contract
  local prompts_dir="$aoc_dir/prompts"
  local pi_low_token_prompt="$prompts_dir/pi-low-token.md"
  if [[ ! -d "$prompts_dir" ]]; then
    log "Creating prompts directory ($prompts_dir)..."
    mkdir -p "$prompts_dir"
  fi
  if [[ ! -f "$pi_low_token_prompt" ]]; then
    log "Seeding PI low-token prompt ($pi_low_token_prompt)..."
    write_pi_low_token_prompt "$pi_low_token_prompt"
  else
    log "PI low-token prompt exists ($pi_low_token_prompt). Preserving."
  fi

  # Context Generation (project-specific, concise, full injection safe)
  local context_file="$aoc_dir/context.md"
  local context_tmp
  local context_line_budget
  local context_tree_depth
  local context_tree_line_budget
  local readme_heading_limit
  local project_name
  local current_branch="unknown"
  local tree_output=""
  local tree_lines=0
  local context_lines=0
  local readme_headings=""

  project_name="$(basename "$project_root")"
  context_tmp="$(mktemp)"
  context_line_budget="$(positive_int_or_default "${AOC_CONTEXT_LINE_BUDGET:-320}" 320)"
  context_tree_depth="$(positive_int_or_default "${AOC_CONTEXT_TREE_DEPTH:-2}" 2)"
  context_tree_line_budget="$(positive_int_or_default "${AOC_CONTEXT_TREE_LINE_BUDGET:-180}" 180)"
  readme_heading_limit="$(positive_int_or_default "${AOC_CONTEXT_README_HEADING_LIMIT:-40}" 40)"

  if command -v git >/dev/null 2>&1 && git -C "$project_root" rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    current_branch="$(git -C "$project_root" branch --show-current 2>/dev/null || true)"
    if [[ -z "$current_branch" ]]; then
      current_branch="$(git -C "$project_root" rev-parse --short HEAD 2>/dev/null || echo "detached")"
    fi
  fi

  if command -v tree >/dev/null 2>&1; then
    tree_output="$(tree -L "$context_tree_depth" --gitignore -I '.git|.taskmaster|.aoc|.gemini|node_modules|target|dist|archive|deprecated|.venv|venv|__pycache__' "$project_root" 2>/dev/null || true)"
    tree_lines="$(printf '%s\n' "$tree_output" | wc -l | tr -d ' ')"
  fi

  if [[ -f "$project_root/README.md" ]]; then
    readme_headings="$(grep -E '^#{1,6} ' "$project_root/README.md" | head -n "$readme_heading_limit" || true)"
  fi

  log "Generating/Updating Context ($context_file)..."

  {
    echo "# Project Context Snapshot"
    echo
    echo "## Repository"
    echo "- Name: $project_name"
    echo "- Root: $project_root"
    echo "- Git branch: $current_branch"

    echo
    echo "## Key Files"
    local found_key_file=0
    local key_file
    for key_file in \
      "README.md" \
      "Makefile" \
      "justfile" \
      "package.json" \
      "pnpm-lock.yaml" \
      "yarn.lock" \
      "bun.lockb" \
      "Cargo.toml" \
      "go.mod" \
      "pyproject.toml" \
      "requirements.txt" \
      "Dockerfile" \
      "docker-compose.yml" \
      "docker-compose.yaml"; do
      if [[ -f "$project_root/$key_file" ]]; then
        echo "- $key_file"
        found_key_file=1
      fi
    done
    if [[ "$found_key_file" == "0" ]]; then
      echo "- No common manifest files detected."
    fi

    echo
    echo "## Project Structure (tree -L $context_tree_depth)"
    echo '```'
    if [[ -n "$tree_output" ]]; then
      if (( tree_lines > context_tree_line_budget )); then
        printf '%s\n' "$tree_output" | head -n "$context_tree_line_budget"
        echo "... [tree truncated to ${context_tree_line_budget} lines]"
      else
        printf '%s\n' "$tree_output"
      fi
    else
      echo "tree command not found"
    fi
    echo '```'

    if [[ -n "$readme_headings" ]]; then
      echo
      echo "## README Headings"
      printf '%s\n' "$readme_headings"
    fi

    echo
    echo "## Current Task Tag"
    echo '```'
    if command -v tm >/dev/null 2>&1; then
      (cd "$project_root" && tm tag current 2>/dev/null || echo "unknown")
    elif command -v aoc-task >/dev/null 2>&1; then
      (cd "$project_root" && aoc-task tag current 2>/dev/null || echo "unknown")
    elif command -v aoc-cli >/dev/null 2>&1; then
      (cd "$project_root" && aoc-cli task tag current 2>/dev/null || echo "unknown")
    elif command -v task-master >/dev/null 2>&1; then
      echo "task-master does not expose current tag"
    else
      echo "Task command not found."
    fi
    echo '```'

    echo
    echo "## Active Workstreams (Tags)"
    echo '```'
    if command -v tm >/dev/null 2>&1; then
      (cd "$project_root" && tm tag list 2>/dev/null || echo "No tags found.")
    elif command -v aoc-task >/dev/null 2>&1; then
      (cd "$project_root" && aoc-task tag list 2>/dev/null || echo "No tags found.")
    elif command -v aoc-cli >/dev/null 2>&1; then
      (cd "$project_root" && aoc-cli task tag list 2>/dev/null || echo "No tags found.")
    elif command -v task-master >/dev/null 2>&1; then
      (cd "$project_root" && task-master tags 2>/dev/null || echo "No tags found.")
    else
      echo "Task command not found."
    fi
    echo '```'

    echo
    echo "## Task PRD Location"
    echo "- Directory: .taskmaster/docs/prds"
    echo "- Resolve tag PRD default with: aoc-task tag prd show --tag <tag>"
    echo "- Resolve task PRD override with: aoc-task prd show <id> --tag <tag>"
    echo "- Effective precedence: task PRD override -> tag PRD default"
  } > "$context_tmp"

  context_lines="$(wc -l < "$context_tmp" | tr -d ' ')"
  if (( context_lines > context_line_budget )); then
    {
      head -n "$context_line_budget" "$context_tmp"
      echo
      echo "... [context capped at ${context_line_budget} lines; adjust AOC_CONTEXT_LINE_BUDGET if needed]"
    } > "$context_file"
    rm -f "$context_tmp"
    log "Context exceeded budget (${context_lines} lines); wrote capped context (${context_line_budget} lines)."
  else
    mv "$context_tmp" "$context_file"
  fi

  # Setup .cursorrules symlink for universal agent awareness
  local cursor_rules="$project_root/.cursorrules"
  if [[ ! -e "$cursor_rules" ]]; then
    log "Creating .cursorrules symlink..."
    ln -s ".aoc/context.md" "$cursor_rules"
  elif [[ -L "$cursor_rules" ]]; then
    log "Existing .cursorrules symlink found. Skipping."
  else
    log "Existing .cursorrules file found. Skipping."
  fi

}

# 1b. Setup skill sync (PI-first)
setup_skills() {
  local pi_skills_dir="$project_root/.pi/skills"
  local legacy_target=""
  local legacy_targets=(
    "$project_root/.codex/skills"
    "$project_root/.claude/skills"
    "$project_root/.opencode/skills"
    "$project_root/.agents/skills"
  )

  upgrade_stm_skill_guidance "$pi_skills_dir"

  if [[ -x "$script_dir/aoc-skill" ]]; then
    log "Ensuring PI skill baseline (.pi/skills)..."
    (cd "$project_root" && "$script_dir/aoc-skill" sync --agent pi --root "$project_root" || true)
  elif command -v aoc-skill >/dev/null 2>&1; then
    log "Ensuring PI skill baseline (.pi/skills)..."
    (cd "$project_root" && aoc-skill sync --agent pi --root "$project_root" || true)
  else
    warn "aoc-skill not found; .pi/skills baseline may be incomplete."
  fi

  for legacy_target in "${legacy_targets[@]}"; do
    if [[ -d "$legacy_target" ]]; then
      warn "Legacy non-PI skill target detected ($legacy_target); aoc-init no longer syncs it automatically in PI-first mode."
    fi
  done
}

upgrade_stm_skill_guidance() {
  local skills_dir="$1"
  local stm_skill="$skills_dir/stm-ops/SKILL.md"
  local memory_skill="$skills_dir/memory-ops/SKILL.md"
  local workflow_skill="$skills_dir/aoc-workflow/SKILL.md"
  local init_ops_skill="$skills_dir/aoc-init-ops/SKILL.md"

  if [[ -f "$stm_skill" ]] && (
    grep -Fq 'aoc-stm --last' "$stm_skill" ||
    grep -Fq 'aoc-stm use <archive>' "$stm_skill" ||
    grep -Fq 'fresh tab/session' "$stm_skill" ||
    grep -Fq 'aoc-stm handoff` (read current draft, fallback to latest archive)' "$stm_skill" ||
    ! grep -Fq 'aoc-stm resume' "$stm_skill"
  ); then
    cat <<'EOF' > "$stm_skill"
---
name: stm-ops
description: Capture and read short-term diary context with aoc-stm.
---

## When to use
- Context window is getting tight and you need to summarize current execution state.
- You need to load current draft STM context into the terminal transcript.

## Commands
- `aoc-stm add "<note>"`
- `aoc-stm edit`
- `aoc-stm` (default read current draft)
- `aoc-stm read-current`
- `aoc-stm handoff` (archive current draft and print handoff snapshot)
- `aoc-stm resume` (read archived handoff snapshot; latest by default)
- `aoc-stm archive`
- `aoc-stm read` (read latest archive)
- `aoc-stm history`
- `aoc-stm read <archive>`

## Handoff format (recommended)
- Objective and task/subtask IDs
- Done / in-progress / blocked
- Files touched and key command outcomes
- Open decisions + assumptions
- Next 3-5 concrete steps

## Guardrails
- Keep STM as a project diary: write/edit in current draft via `aoc-stm`, then seal clean checkpoints with `aoc-stm handoff`.
- Promote durable decisions to `aoc-mem add`, not STM.
- Do not edit `tasks.json` directly while preparing handoff state.
EOF
    log "Updated stm-ops skill with draft-seal-resume STM guidance."
  fi

  if [[ -f "$memory_skill" ]] && (
    grep -Fq 'aoc-stm handoff` (read current draft, fallback to latest archive)' "$memory_skill" ||
    ! grep -Fq 'aoc-stm resume' "$memory_skill"
  ); then
    cat <<'EOF' > "$memory_skill"
---
name: memory-ops
description: Use aoc-mem to read, search, and record project decisions.
---

## Commands
- `aoc-mem read`
- `aoc-mem search "<term>"`
- `aoc-mem add "<decision>"`
- `aoc-stm add "<handoff note>"`
- `aoc-stm edit`
- `aoc-stm` (read current draft)
- `aoc-stm handoff` (archive current draft and print handoff snapshot)
- `aoc-stm resume` (read archived handoff snapshot; latest by default)
- `aoc-stm archive`
- `aoc-stm read` (read latest archive)
- `aoc-stm history`

## Recording guidelines
- Capture the "why" behind decisions.
- Keep entries short and scoped.
- Record one decision per line.

## Guardrail
- Never edit `.aoc/memory.md` directly.
- Keep `.aoc/stm/current.md` as an in-progress draft and archive it often so STM becomes a durable project diary.
EOF
    log "Updated memory-ops skill with STM command guidance."
  fi

  if [[ -f "$workflow_skill" ]] && (
    grep -Fq 'aoc task list' "$workflow_skill" ||
    grep -Fq 'aoc task add' "$workflow_skill" ||
    grep -Fq 'aoc task status' "$workflow_skill" ||
    grep -Fq 'review current draft with `aoc-stm`' "$workflow_skill" ||
    ! grep -Fq 'aoc-stm resume' "$workflow_skill"
  ); then
    cat <<'EOF' > "$workflow_skill"
---
name: aoc-workflow
description: Standard AOC workflow using context, memory, and tasks.
---

## When to use
Use this when you start a new task or need to re-orient inside a project.

## Steps
1. If AOC files are missing or stale, run `aoc-init` from the project root.
2. Read memory: `aoc-mem read` and `aoc-mem search "<topic>"` as needed.
3. Resolve active tag at session start with `tm tag current` (or `aoc-task tag current`).
4. Review tasks: `tm list`, `aoc-task list`, or the Taskmaster TUI.
5. Check PRD linkage for scope and task:
   - Tag default: `aoc-task tag prd show --tag <tag>`
   - Task override: `aoc-task prd show <id> --tag <tag>`
6. Plan: add or refine tasks with `aoc-task add "<task>"` and set status.
7. Execute changes and run tests.
8. If context gets tight, capture state (`aoc-stm add/edit`), seal a clean checkpoint with `aoc-stm handoff`, and use `aoc-stm resume` (or `aoc-stm read`) to load resumable archived context in a new session.
9. Update tasks and record decisions: `aoc-task status <id> done`, `aoc-mem add "<decision>"`.

## Guardrails
- Do not edit `.aoc/memory.md` directly.
- Do not keep long-term decisions in `.aoc/stm/current.md`; promote durable decisions to `aoc-mem`.
- Do not edit `.taskmaster/tasks/tasks.json` directly.
- Do not add PRD links to subtasks.
- Use tag-level PRD defaults with task-level overrides (`aocPrd`), with precedence task -> tag.
EOF
    log "Updated aoc-workflow skill with draft-seal-resume STM guidance."
  fi

  if [[ -f "$init_ops_skill" ]] && (
    ! grep -Fq '.aoc/stm/current.md' "$init_ops_skill" ||
    ! grep -Fq '.pi/prompts/' "$init_ops_skill" ||
    ! grep -Fq '/tm-cc' "$init_ops_skill" ||
    ! grep -Fq 'aoc-stm handoff' "$init_ops_skill" ||
    ! grep -Fq 'aoc-stm resume' "$init_ops_skill" ||
    ! grep -Fq '.pi/extensions/' "$init_ops_skill" ||
    grep -Fq 'Syncs skills for existing agent targets' "$init_ops_skill"
  ); then
    cat <<'EOF' > "$init_ops_skill"
---
name: aoc-init-ops
description: Initialize or repair AOC context, memory, and tasks safely.
---

## When to use
- New repository setup
- Missing `.aoc/` or `.taskmaster/`
- Stale or inconsistent context

## Run
- `aoc-init`
- To skip Rust builds: `AOC_INIT_SKIP_BUILD=1 aoc-init`

## What it does
- Creates `.aoc/` and `.taskmaster/` if missing
- Generates `.aoc/context.md`
- Seeds `.aoc/memory.md`
- Seeds `.aoc/stm/current.md` and `.aoc/stm/archive/` without overwriting existing STM files
- Ensures PRD directory `.taskmaster/docs/prds/` is available for tag/task links
- Seeds `.pi/settings.json` when missing
- Seeds PI prompt templates in `.pi/prompts/` (`/aoc-ops`, `/teach`, `/teach-full`, `/teach-dive`, `/teach-ask`, `/tm-cc`) when missing
- Seeds PI default extensions in `.pi/extensions/` (`minimal.ts`, `themeMap.ts`) when missing
- Migrates missing legacy PI prompts/skills from `.aoc/prompts/pi/` and `.aoc/skills/` into `.pi/**` (non-destructive), and cleans safe `tmcc` prompt alias duplicates
- Optional MoreMotion prompt `/momo` is seeded by `aoc-momo init`
- Ensures `.pi/skills` baseline (PI-first canonical)
EOF
    log "Updated aoc-init-ops skill with STM seeding guidance."
  fi
}

# 1c. Setup PI settings + baseline directories (.pi/)
setup_pi_settings() {
  local pi_dir="$project_root/.pi"
  local pi_settings="$pi_dir/settings.json"

  if [[ ! -d "$pi_dir" ]]; then
    mkdir -p "$pi_dir"
  fi

  # Deterministic PI-first baseline directory contract.
  mkdir -p "$pi_dir/prompts" "$pi_dir/skills" "$pi_dir/extensions"

  if [[ ! -f "$pi_settings" ]]; then
    cat <<'EOF' > "$pi_settings"
{
  "extensions": []
}
EOF
    log "Seeded PI settings: $pi_settings"
  else
    log "PI settings exist ($pi_settings). Preserving."
  fi
}

discover_pi_extension_template() {
  local extension_file="$1"
  local -a search_roots=(
    "$HOME/dev"
    "$HOME"
  )

  local root=""
  local found=""
  for root in "${search_roots[@]}"; do
    [[ -d "$root" ]] || continue
    found="$(find "$root" -maxdepth 6 -type f -path "*/.pi/extensions/$extension_file" 2>/dev/null | head -n 1 || true)"
    if [[ -n "$found" ]]; then
      printf '%s' "$found"
      return 0
    fi
  done

  return 1
}

write_builtin_pi_extension_template() {
  local extension_file="$1"
  local target_file="$2"

  case "$extension_file" in
    minimal.ts)
      cat <<'EOF' > "$target_file"
import type { ExtensionAPI } from "@mariozechner/pi-coding-agent";
import { applyExtensionDefaults } from "./themeMap.ts";

export default function ({ pi }: ExtensionAPI) {
  pi.on("session_start", async (_event, ctx) => {
    applyExtensionDefaults(import.meta.url, ctx);
  });
}
EOF
      ;;
    themeMap.ts)
      cat <<'EOF' > "$target_file"
import type { ExtensionContext } from "@mariozechner/pi-coding-agent";
import { basename } from "path";
import { fileURLToPath } from "url";

export const THEME_MAP: Record<string, string> = {
  "minimal": "synthwave",
};

function extensionName(fileUrl: string): string {
  const filePath = fileUrl.startsWith("file://") ? fileURLToPath(fileUrl) : fileUrl;
  return basename(filePath).replace(/\.[^.]+$/, "");
}

function primaryExtensionName(): string | null {
  const argv = process.argv;
  for (let i = 0; i < argv.length - 1; i++) {
    if (argv[i] === "-e" || argv[i] === "--extension") {
      return basename(argv[i + 1]).replace(/\.[^.]+$/, "");
    }
  }
  return null;
}

export function applyExtensionTheme(fileUrl: string, ctx?: ExtensionContext): boolean {
  if (!ctx || !ctx.hasUI || !(ctx as any).ui) return false;

  const name = extensionName(fileUrl);
  const primaryExt = primaryExtensionName();
  if (primaryExt && primaryExt !== name) return true;

  const setTheme = (ctx as any).ui?.setTheme;
  if (typeof setTheme !== "function") return false;

  const aocThemeName = (process.env.AOC_PI_THEME_NAME || "").trim();
  const aocThemeLocked = /^(1|true|yes|on)$/i.test((process.env.AOC_PI_THEME_LOCKED || "").trim());

  if (aocThemeName.length > 0) {
    const aocResult = setTheme(aocThemeName);
    if (aocResult?.success) return true;
    if (aocThemeLocked) return false;
  }

  if (aocThemeLocked) return false;

  const themeName = THEME_MAP[name] || "synthwave";
  const result = setTheme(themeName);
  return !!result?.success;
}

export function applyExtensionDefaults(fileUrl: string, ctx?: ExtensionContext): void {
  applyExtensionTheme(fileUrl, ctx);
}

export default function (): void {}
EOF
      ;;
    *)
      return 1
      ;;
  esac

  return 0
}

is_legacy_pi_extension_template() {
  local extension_file="$1"
  local target_file="$2"

  [[ -f "$target_file" ]] || return 1

  case "$extension_file" in
    minimal.ts)
      if grep -Fq 'const mindPart = `âœ¦ [${bar(mindLoadPct)}] ${Math.round(mindLoadPct * 100)}%`;' "$target_file" 2>/dev/null; then
        return 0
      fi
      ;;
  esac

  return 1
}

# 1d. Setup PI default extensions (.pi/extensions)
setup_pi_extensions() {
  local pi_extensions_dir="$project_root/.pi/extensions"
  local global_template_dir="$aoc_config_dir/pi/extensions"
  local candidate=""
  local canonical_seed_dirs=(
    "$script_dir/../.pi/extensions"
    "$global_template_dir"
  )
  local required_extensions=(
    "minimal.ts"
    "themeMap.ts"
  )

  mkdir -p "$pi_extensions_dir" "$global_template_dir"

  local seeded_any=0
  local extension_file=""
  local preferred_seed_file=""
  local discovered_file=""
  local target_file=""
  local cache_file=""
  local managed_target=""
  for extension_file in "${required_extensions[@]}"; do
    target_file="$pi_extensions_dir/$extension_file"
    cache_file="$global_template_dir/$extension_file"

    preferred_seed_file=""
    for candidate in "${canonical_seed_dirs[@]}"; do
      if [[ -f "$candidate/$extension_file" ]]; then
        preferred_seed_file="$candidate/$extension_file"
        break
      fi
    done

    discovered_file=""
    if [[ -z "$preferred_seed_file" ]]; then
      discovered_file="$(discover_pi_extension_template "$extension_file" || true)"
      if [[ -n "$discovered_file" ]]; then
        preferred_seed_file="$discovered_file"
      fi
    fi

    if [[ -f "$target_file" ]]; then
      if [[ -n "$preferred_seed_file" ]] && ! cmp -s "$target_file" "$preferred_seed_file"; then
        managed_target="0"
        for candidate in "${canonical_seed_dirs[@]}"; do
          if [[ -f "$candidate/$extension_file" ]] && cmp -s "$target_file" "$candidate/$extension_file"; then
            managed_target="1"
            break
          fi
        done

        if [[ "$managed_target" != "1" ]] && is_legacy_pi_extension_template "$extension_file" "$target_file"; then
          managed_target="1"
        fi

        if [[ "$managed_target" == "1" ]]; then
          cp "$preferred_seed_file" "$target_file"
          log "Updated PI extension from current template: $extension_file"
          seeded_any=1
        else
          log "PI extension $extension_file already present. Preserving."
        fi
      else
        log "PI extension $extension_file already present. Preserving."
      fi

      if [[ -n "$preferred_seed_file" && "$preferred_seed_file" != "$cache_file" ]]; then
        if [[ ! -f "$cache_file" ]] || ! cmp -s "$preferred_seed_file" "$cache_file"; then
          cp "$preferred_seed_file" "$cache_file" || true
          log "Refreshed global PI extension template: $extension_file"
        fi
      fi
      continue
    fi

    if [[ -n "$preferred_seed_file" ]]; then
      cp "$preferred_seed_file" "$target_file"
      log "Seeded PI extension: $extension_file"
      seeded_any=1
      if [[ -n "$preferred_seed_file" && "$preferred_seed_file" != "$cache_file" ]]; then
        if [[ ! -f "$cache_file" ]] || ! cmp -s "$preferred_seed_file" "$cache_file"; then
          cp "$preferred_seed_file" "$cache_file" || true
          log "Refreshed global PI extension template: $extension_file"
        fi
      fi
      continue
    fi

    if write_builtin_pi_extension_template "$extension_file" "$target_file"; then
      log "Seeded PI extension (builtin fallback): $extension_file"
      seeded_any=1
      if [[ ! -f "$cache_file" ]]; then
        cp "$target_file" "$cache_file" || true
      fi
      continue
    fi

    warn "Missing PI extension template: $extension_file"
  done

  if [[ "$seeded_any" != "1" ]]; then
    log "PI default extensions already present in .pi/extensions. Preserving."
  fi
}

# 1e. Migrate legacy PI runtime assets from project-local .aoc paths
migrate_legacy_pi_assets() {
  local pi_prompts_dir="$project_root/.pi/prompts"
  local pi_skills_dir="$project_root/.pi/skills"
  local legacy_prompts_dir="$aoc_dir/prompts/pi"
  local legacy_skills_dir="$aoc_dir/skills"

  local legacy_prompt=""
  local legacy_prompt_name=""
  local canonical_prompt_name=""
  local target_prompt=""

  if [[ -d "$legacy_prompts_dir" ]]; then
    shopt -s nullglob
    local legacy_prompts=("$legacy_prompts_dir"/*.md)
    shopt -u nullglob
    for legacy_prompt in "${legacy_prompts[@]}"; do
      legacy_prompt_name="$(basename "$legacy_prompt")"
      canonical_prompt_name="$legacy_prompt_name"
      if [[ "$legacy_prompt_name" == "tmcc.md" ]]; then
        canonical_prompt_name="tm-cc.md"
      fi
      target_prompt="$pi_prompts_dir/$canonical_prompt_name"
      if [[ ! -f "$target_prompt" ]]; then
        cp "$legacy_prompt" "$target_prompt"
        log "Migrated legacy PI prompt: .aoc/prompts/pi/$legacy_prompt_name -> .pi/prompts/$canonical_prompt_name"
      elif ! cmp -s "$legacy_prompt" "$target_prompt"; then
        warn "Legacy prompt differs from canonical (.aoc/prompts/pi/$legacy_prompt_name vs .pi/prompts/$canonical_prompt_name). Preserving canonical file."
      fi
    done
  fi

  local alias_prompt="$pi_prompts_dir/tmcc.md"
  local canonical_tmcc_prompt="$pi_prompts_dir/tm-cc.md"
  if [[ -f "$alias_prompt" ]]; then
    if [[ ! -f "$canonical_tmcc_prompt" ]]; then
      mv "$alias_prompt" "$canonical_tmcc_prompt"
      log "Migrated legacy PI prompt alias: .pi/prompts/tmcc.md -> .pi/prompts/tm-cc.md"
    elif cmp -s "$alias_prompt" "$canonical_tmcc_prompt"; then
      rm -f "$alias_prompt"
      log "Removed legacy PI prompt alias duplicate: .pi/prompts/tmcc.md"
    else
      warn "Legacy PI prompt alias .pi/prompts/tmcc.md differs from .pi/prompts/tm-cc.md; preserving both for manual merge."
    fi
  fi

  local legacy_skill_dir=""
  local legacy_skill_name=""
  local canonical_skill_name=""
  local target_skill_dir=""
  if [[ -d "$legacy_skills_dir" ]]; then
    shopt -s nullglob
    local legacy_skill_entries=("$legacy_skills_dir"/*)
    shopt -u nullglob
    for legacy_skill_dir in "${legacy_skill_entries[@]}"; do
      [[ -d "$legacy_skill_dir" ]] || continue
      [[ -f "$legacy_skill_dir/SKILL.md" ]] || continue
      legacy_skill_name="$(basename "$legacy_skill_dir")"
      canonical_skill_name="$legacy_skill_name"
      if [[ "$legacy_skill_name" == "tmcc" ]]; then
        canonical_skill_name="tm-cc"
      fi
      target_skill_dir="$pi_skills_dir/$canonical_skill_name"
      if [[ ! -e "$target_skill_dir" ]]; then
        mkdir -p "$target_skill_dir"
        cp -R "$legacy_skill_dir"/. "$target_skill_dir"/
        log "Migrated legacy PI skill: .aoc/skills/$legacy_skill_name -> .pi/skills/$canonical_skill_name"
      elif [[ -f "$target_skill_dir/SKILL.md" ]] && ! cmp -s "$legacy_skill_dir/SKILL.md" "$target_skill_dir/SKILL.md"; then
        warn "Legacy skill differs from canonical (.aoc/skills/$legacy_skill_name vs .pi/skills/$canonical_skill_name). Preserving canonical skill."
      fi
    done
  fi
}

# 1f. Setup PI Prompt Templates (.pi/prompts)
setup_pi_prompts() {
  local pi_prompts_dir="$project_root/.pi/prompts"
  local candidate=""
  local canonical_seed_dirs=(
    "$aoc_config_dir/pi/prompts"
    "$script_dir/../.pi/prompts"
  )
  local legacy_seed_dirs=(
    "$aoc_config_dir/prompts/pi"
    "$script_dir/../.aoc/prompts/pi"
  )
  local required_prompts=(
    "aoc-ops"
    "teach"
    "teach-full"
    "teach-dive"
    "teach-ask"
    "tm-cc"
  )

  if [[ ! -d "$pi_prompts_dir" ]]; then
    mkdir -p "$pi_prompts_dir"
  fi

  local seeded_any=0
  local prompt_name=""
  local seed_file=""
  local seed_mode=""
  local target_file=""
  for prompt_name in "${required_prompts[@]}"; do
    seed_file=""
    seed_mode=""

    for candidate in "${canonical_seed_dirs[@]}"; do
      if [[ -f "$candidate/${prompt_name}.md" ]]; then
        seed_file="$candidate/${prompt_name}.md"
        seed_mode="canonical"
        break
      fi
    done

    if [[ -z "$seed_file" ]]; then
      for candidate in "${legacy_seed_dirs[@]}"; do
        if [[ -f "$candidate/${prompt_name}.md" ]]; then
          seed_file="$candidate/${prompt_name}.md"
          seed_mode="legacy"
          break
        fi
      done
    fi

    if [[ -z "$seed_file" ]]; then
      warn "Missing PI prompt template: /$prompt_name"
      continue
    fi

    if [[ "$seed_mode" == "legacy" ]]; then
      log "Using legacy prompt source for /$prompt_name (compatibility window)."
    fi

    target_file="$pi_prompts_dir/${prompt_name}.md"
    if [[ ! -f "$target_file" ]]; then
      cp "$seed_file" "$target_file"
      log "Seeded PI prompt: /$prompt_name"
    else
      log "PI prompt /$prompt_name already present. Preserving."
    fi
    seeded_any=1
  done

  if [[ "$seeded_any" != "1" ]]; then
    warn "No PI prompt templates found; skipping PI prompt seeding."
  fi

  if [[ -f "$pi_prompts_dir/tmcc.md" ]]; then
    log "Legacy PI prompt alias /tmcc detected; preserving file but alias is no longer seeded."
  fi
}

# 1g. Setup PI Skill Templates (.pi/skills)
setup_pi_skills() {
  local pi_skills_dir="$project_root/.pi/skills"
  local candidate=""
  local canonical_seed_dirs=(
    "$aoc_config_dir/pi/skills"
    "$script_dir/../.pi/skills"
  )
  local legacy_seed_dirs=(
    "$aoc_config_dir/skills"
    "$script_dir/../.aoc/skills"
  )

  mkdir -p "$pi_skills_dir"

  local seed_dir=""
  local seed_mode=""
  local skill_list=()

  for candidate in "${canonical_seed_dirs[@]}"; do
    [[ -d "$candidate" ]] || continue
    shopt -s nullglob
    skill_list=("$candidate"/*/SKILL.md)
    shopt -u nullglob
    if ((${#skill_list[@]} > 0)); then
      seed_dir="$candidate"
      seed_mode="canonical"
      break
    fi
  done

  if [[ -z "$seed_dir" ]]; then
    for candidate in "${legacy_seed_dirs[@]}"; do
      [[ -d "$candidate" ]] || continue
      shopt -s nullglob
      skill_list=("$candidate"/*/SKILL.md)
      shopt -u nullglob
      if ((${#skill_list[@]} > 0)); then
        seed_dir="$candidate"
        seed_mode="legacy"
        break
      fi
    done
  fi

  if [[ -z "$seed_dir" ]]; then
    warn "No PI skill templates found; skipping PI skill seeding."
    return
  fi

  if [[ "$seed_mode" == "legacy" ]]; then
    log "Using legacy skill source for PI skill seeding (compatibility window)."
  fi

  local copied_any=0
  local seed_skill_dir=""
  local skill_name=""
  local target_skill_dir=""

  shopt -s nullglob
  local seed_entries=("$seed_dir"/*)
  shopt -u nullglob
  for seed_skill_dir in "${seed_entries[@]}"; do
    [[ -d "$seed_skill_dir" ]] || continue
    [[ -f "$seed_skill_dir/SKILL.md" ]] || continue
    skill_name="$(basename "$seed_skill_dir")"
    target_skill_dir="$pi_skills_dir/$skill_name"
    if [[ ! -e "$target_skill_dir" ]]; then
      mkdir -p "$target_skill_dir"
      cp "$seed_skill_dir/SKILL.md" "$target_skill_dir/SKILL.md"
      copied_any=1
    fi
  done

  if [[ "$copied_any" == "1" ]]; then
    log "Seeded PI skills into .pi/skills."
  else
    log "PI skills already present in .pi/skills. Preserving."
  fi
}

# 2. Setup Taskmaster (.taskmaster/)
setup_tasks() {
  log "Initializing Taskmaster..."

  mkdir -p "$task_dir/tasks" "$task_dir/docs/prds" "$task_dir/reports" "$task_dir/templates"

  local native_init_ok=0
  if command -v aoc-task >/dev/null 2>&1; then
    if (cd "$project_root" && aoc-task init >/dev/null 2>&1); then
      native_init_ok=1
    else
      warn "aoc-task init failed; using shell fallback for task scaffolding."
    fi
  elif command -v aoc-cli >/dev/null 2>&1; then
    if (cd "$project_root" && aoc-cli task init >/dev/null 2>&1); then
      native_init_ok=1
    else
      warn "aoc-cli task init failed; using shell fallback for task scaffolding."
    fi
  fi

  if [[ "$native_init_ok" != "1" ]]; then
    if [[ ! -f "$task_dir/tasks/tasks.json" ]]; then
      cat <<EOF > "$task_dir/tasks/tasks.json"
{
  "master": {
    "tasks": []
  }
}
EOF
    fi

    if [[ ! -f "$task_dir/state.json" ]]; then
      now_stamp="$(date -u +%Y-%m-%dT%H:%M:%S.%3NZ)"
      cat <<EOF > "$task_dir/state.json"
{
  "currentTag": "master",
  "lastUpdated": "${now_stamp}",
  "lastSwitched": "${now_stamp}",
  "branchTagMapping": {},
  "migrationNoticeShown": true
}
EOF
    fi
  fi

  local template_name=""
  local template_src=""
  local candidate=""
  local template_candidates=(
    "$aoc_config_dir/taskmaster/templates"
    "$script_dir/../.taskmaster/templates"
  )

  for template_name in "example_prd.txt" "example_prd_rpg.txt"; do
    if [[ -f "$task_dir/templates/$template_name" ]]; then
      continue
    fi
    template_src=""
    for candidate in "${template_candidates[@]}"; do
      if [[ -f "$candidate/$template_name" ]]; then
        template_src="$candidate/$template_name"
        break
      fi
    done
    if [[ -n "$template_src" ]]; then
      cp "$template_src" "$task_dir/templates/$template_name"
      log "Seeded Taskmaster template: $task_dir/templates/$template_name"
    else
      warn "No upstream template found for $template_name."
    fi
  done

  local project_prd="$task_dir/docs/prd.md"
  if [[ ! -f "$project_prd" ]]; then
    if [[ -f "$task_dir/templates/example_prd.txt" ]]; then
      cp "$task_dir/templates/example_prd.txt" "$project_prd"
      log "Seeded project PRD from upstream template: $project_prd"
    else
      cat <<'EOF' > "$project_prd"
# Product Requirements Document

## Problem
Describe the core user problem this project solves.

## Goals
-

## Non-Goals
-

## User Stories
- As a <user>, I want <capability> so that <outcome>.

## Requirements
-

## Acceptance Criteria
- [ ]

## Constraints
-

## Risks
-

## Test Strategy
-
EOF
      log "Seeded fallback project PRD template: $project_prd"
    fi
  fi

  local project_prd_txt="$task_dir/docs/prd.txt"
  if [[ -f "$project_prd" && ! -f "$project_prd_txt" ]]; then
    cp "$project_prd" "$project_prd_txt"
    log "Seeded Taskmaster-compatible project PRD copy: $project_prd_txt"
  fi

  # Config Seeding (Preserve existing logic, but ensure Gemini preference)
  local local_conf="$task_dir/config.json"
  
  if [[ -f "$global_task_conf" ]]; then
    if [[ ! -f "$local_conf" ]]; then
      log "Seeding Taskmaster config from global defaults..."
      cp "$global_task_conf" "$local_conf"
    else
      # Advanced: We could merge JSON here, but for now we trust the local config
      # if it exists, assuming the user might have customized it for this specific repo.
      log "Local Taskmaster config exists. Preserving."
    fi
  else
    warn "No global Taskmaster config found at $global_task_conf. Skipping seed."
  fi
}

# 3. Environment Checks
setup_env() {
  if [[ ! -f "$project_root/.env" && -f "$project_root/.env.example" ]]; then
    log "Copying .env.example to .env..."
    cp "$project_root/.env.example" "$project_root/.env"
  fi
}

# 4. Ensure AOC Rust binaries are available
setup_binaries() {
  if [[ "${AOC_INIT_SKIP_BUILD:-0}" == "1" ]]; then
    log "Skipping Rust binary build (AOC_INIT_SKIP_BUILD=1)."
    return
  fi

  local manifest_path=""
  if [[ -f "$project_root/crates/Cargo.toml" ]]; then
    manifest_path="$project_root/crates/Cargo.toml"
  elif [[ -f "$script_dir/../crates/Cargo.toml" ]]; then
    manifest_path="$script_dir/../crates/Cargo.toml"
  fi

  local required=(aoc-hub-rs aoc-agent-wrap-rs aoc-mission-control aoc-taskmaster aoc-control)
  local missing=()
  local bin=""
  local manifest_dir=""
  if [[ -n "$manifest_path" ]]; then
    manifest_dir="$(dirname "$manifest_path")"
  fi

  for bin in "${required[@]}"; do
    if command -v "$bin" >/dev/null 2>&1; then
      continue
    fi
    if [[ -n "$manifest_dir" ]]; then
      if [[ -x "$manifest_dir/target/release/$bin" || -x "$manifest_dir/target/debug/$bin" ]]; then
        continue
      fi
    fi
    missing+=("$bin")
  done

  if ((${#missing[@]} == 0)); then
    log "Rust binaries already available. Skipping build."
    return
  fi

  if [[ -z "$manifest_path" ]]; then
    warn "Rust workspace not found. Missing binaries: ${missing[*]}"
    return
  fi

  if ! command -v cargo >/dev/null 2>&1; then
    warn "cargo not found; unable to build binaries: ${missing[*]}"
    return
  fi

  log "Building AOC Rust binaries: ${required[*]}"
  cargo build --manifest-path "$manifest_path" -p aoc-hub-rs -p aoc-agent-wrap-rs -p aoc-mission-control -p aoc-taskmaster -p aoc-control
}

main() {
  log "Initializing AOC in: $project_root"
  setup_memory
  setup_pi_settings
  setup_pi_extensions
  migrate_legacy_pi_assets
  setup_pi_prompts
  setup_pi_skills
  setup_skills
  setup_tasks
  ensure_git_tracking_policy
  setup_env
  setup_binaries
  log "AOC Initialization Complete. Ready to launch."
}

main
