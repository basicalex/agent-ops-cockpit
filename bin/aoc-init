#!/usr/bin/env bash
set -euo pipefail

# AOC Initialization Script
# Usage: aoc-init [path]
#
# This script standardizes a project for the Agent Ops Cockpit.
# It is IDEMPOTENT: safe to run multiple times. It respects existing data.

project_root="${1:-$PWD}"
aoc_dir="$project_root/.aoc"
gemini_dir="$project_root/.gemini"
task_dir="$project_root/.taskmaster"
global_task_conf="$HOME/.taskmaster/config.json"
aoc_config_dir="${XDG_CONFIG_HOME:-$HOME/.config}/aoc"
script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

log() { echo ">> $1"; }
warn() { echo "!! $1"; }

positive_int_or_default() {
  local candidate="$1"
  local fallback="$2"
  if [[ "$candidate" =~ ^[0-9]+$ ]] && (( candidate > 0 )); then
    printf '%s' "$candidate"
  else
    printf '%s' "$fallback"
  fi
}

write_aoc_agents_contract() {
  local target_file="$1"
  cat <<'EOF' > "$target_file"
# AOC Architecture & Agent Guidelines

This file defines the always-on rules for agents in this repo. Procedural playbooks live in AOC skills.

## Always-on rules
- Use `.aoc/context.md` for orientation; run `aoc-init` if it is missing or stale.
- **DO NOT manually read these files** - use the Bash tool to run CLI commands instead (see below).
- Run AOC commands via Bash tool - do NOT use Read tool for `.aoc/memory.md`, `.aoc/stm/current.md`, or `.taskmaster/tasks/tasks.json`.
- RTK routing is default-on for new AOC projects (`.aoc/rtk.toml` mode=`on`); existing explicit mode=`off` is preserved.
- RTK exists to improve context health: allowlisted noisy commands are condensed for better signal density, with fail-open native fallback.

## Low-Token Default Mode
- Keep responses concise by default; do not print full files or raw logs unless explicitly requested.
- Start with the smallest viable step; use narrow, path-scoped searches before broad scans.
- Read files in bounded chunks and avoid rereading unchanged large files.
- Summarize command/tool output with actionable lines only (key errors, next actions).
- Run targeted checks/tests first; run full-suite commands only when required.
- If targeted inspection fails, escalate scope gradually and state why.
- Use fresh sessions after major milestones or context drift to reduce replay overhead.
- For narrow diagnostics/Q&A, use at most 3 tool calls before first answer; ask before broader escalation.
- Do not open/read image binaries unless the user explicitly asks to view/open one now.
- Use one narrow diagnostic path first; avoid retry spray with variant commands unless first attempt fails.

## AOC CLI Commands (run via Bash tool - NOT Read tool)
These commands are in PATH and work without loading any skill:

**Memory:**
- `aoc-mem read` - read persistent memory
- `aoc-mem add "decision"` - record architectural decision

**Short-Term Memory (STM):**
- `aoc-stm` - print current draft (shortcut for `aoc-stm read-current`)
- `aoc-stm handoff` - archive current draft and print handoff snapshot
- `aoc-stm resume` - print archived handoff snapshot (latest by default)
- `aoc-stm read` - read latest archived snapshot
- `aoc-stm archive` - archive current draft
- `aoc-stm add "note"` - add to current draft
- `aoc-stm edit` - edit current draft in editor

**Tasks:**
- `tm list` - list tasks (alias for `aoc-task`)
- `tm add "Task name"` - add new task
- `tm tag current` - print effective active tag
- `tm tag prd show` - show PRD linked to active tag
- `aoc-task tag prd show --tag <tag>` - show PRD linked to a specific tag
- `tm` - open Taskmaster TUI

**Other:**
- `aoc-init` - initialize/repair AOC files
- `aoc-mem search "query"` - search memory
- `aoc-rtk status` - check RTK routing status
- `aoc-rtk enable|disable` - toggle RTK routing mode
- `aoc-rtk doctor` - run RTK diagnostics
- `aoc-rtk install --auto` - auto-fetch and install pinned RTK binary

## Core files
- `.aoc/context.md`: auto-generated project snapshot.
- `.aoc/rtk.toml`: project-local RTK routing policy and install contract.
- `.aoc/layouts/`: project-shared Zellij layouts for AOC (`*.kdl`).
- `.taskmaster/docs/prds/`: PRD documents linked to tags and tasks.
- Tag PRD defaults are linked via tag `aocPrd`; resolve with `aoc-task tag prd show --tag <tag>`.
- Task PRD overrides are linked via task `aocPrd`; resolve with `aoc-task prd show <id> --tag <tag>`.
- Effective precedence is task PRD override -> tag PRD default.
- Keep task PRDs in git: `.taskmaster/docs/prds/**` should always be tracked.
- Keep AOC/task state in git: `.aoc/**` and `.taskmaster/**` should not be ignored.

## Task Management
- `.taskmaster/tasks/tasks.json` is task state; use the Taskmaster TUI, `aoc-task`, or `tm` (alias for `aoc-task`). Do not edit the file directly.
- Record major decisions and constraints in memory (`aoc-mem add "..."`).

## Skills (load when needed)
- `aoc-workflow`: standard project workflow.
- `teach-workflow`: guided teach-mode scans, dives, and local insight logging.
- `rlm-analysis`: large codebase analysis flow.
- `prd-dev`: draft the Taskmaster PRD.
- `prd-intake`: parse a project PRD into initial task sets.
- `prd-align`: align tasks with the PRD.
- `tag-align`: normalize task tags and dependencies.
- `task-breakdown`: expand a task into clear subtasks.
- `task-checker`: verify implementation vs. testStrategy.
- `release-notes`: draft changelog and release notes.
- `skill-creator`: create or update AOC skills.
- `zellij-theme-ops`: create and manage global Zellij themes.

Note: `aoc-mem`, `aoc-stm`, and `tm` are basic CLI commands (see above) - no skill needed.
EOF
}

write_pi_low_token_prompt() {
  local target_file="$1"
  cat <<'EOF' > "$target_file"
# PI Low-Token Mode (AOC Default)

Apply these defaults unless the user asks for higher detail.

- Keep replies concise and actionable (default: <= 8 bullets).
- Start with direct path guesses before searching. Example: if asked about screenshot tool, check `.pi/extensions/latest-screenshot.ts` first.
- Avoid broad scans by default. Do NOT run `tm list`, `git status`, or repo-wide `rg` unless the user asks or a targeted check fails.
- Use the fewest tool calls needed. For simple locate/explain requests, limit to 1-3 focused reads.
- Hard budget before first answer: at most 3 tool calls unless the first attempt fails.
- If unresolved after 3 calls, ask before broader escalation.
- For "does tool X work" checks, do only: (1) read tool file/settings, (2) run the tool once, then report.
- Read only minimal slices first; avoid rereading unchanged large files.
- Never dump large raw output. Summarize key lines and include file paths only.
- Do not read/open image files unless the user explicitly asks to view/open the image now.
- Run targeted tests/checks first; escalate to full-suite only when required.
- If you must widen scope, state why in one short line and widen one step at a time.
EOF
}

ensure_agents_contract() {
  local agents_file="$1"

  if [[ ! -f "$agents_file" ]]; then
    log "Creating AGENTS.md..."
    write_aoc_agents_contract "$agents_file"
    return
  fi

  if grep -Eq "AOC Architecture & Agent Guidelines|Agent Ops Cockpit \(AOC\)" "$agents_file"; then
    local tmp_agents
    tmp_agents="$(mktemp)"
    write_aoc_agents_contract "$tmp_agents"
    if ! cmp -s "$tmp_agents" "$agents_file"; then
      cp "$tmp_agents" "$agents_file"
      log "Updated AGENTS.md to latest AOC contract."
    else
      log "AGENTS.md already up to date."
    fi
    rm -f "$tmp_agents"
    return
  fi

  if grep -Fq "## Agent Ops Cockpit (AOC)" "$agents_file"; then
    log "Existing AGENTS.md already includes an AOC section. Preserving."
    return
  fi

  log "Appending AOC command guidance to existing AGENTS.md..."
  cat <<'EOF' >> "$agents_file"

## Agent Ops Cockpit (AOC)
Use the AOC tools for context, memory, and tasks in this repo.

- **Context:** `.aoc/context.md` (auto-generated project map)
- **Memory:** use `aoc-mem read/search/add` via Bash tool (do not edit `.aoc/memory.md` directly)
- **Short-term memory:** use `aoc-stm` (draft), `aoc-stm handoff` (seal), and `aoc-stm resume`/`aoc-stm read` (resume) via Bash tool (do not read `.aoc/stm/current.md` directly)
- **Tasks:** use `tm` or `aoc-task` via Bash tool (do not edit `.taskmaster/tasks/tasks.json` directly)
- **Task PRDs:** tag-level defaults + task-level overrides via `aocPrd` (resolve with `aoc-task tag prd show --tag <tag>` and `aoc-task prd show <id> --tag <tag>`)
- **RTK routing (default-on for new AOC repos):** allowlisted commands route via RTK in AOC panes; manage with `aoc-rtk status|enable|disable|doctor|install --auto` and `.aoc/rtk.toml`

If AOC files are missing or stale, run `aoc-init` at the repo root.
EOF
}

write_default_rtk_config() {
  local target_file="$1"
  cat <<'EOF' > "$target_file"
# AOC RTK routing config (project-local, seeded by aoc-init)
# mode: off|on
mode = "on"
fail_open = true
# gain_mode: double-dash|positional
gain_mode = "double-dash"
binary = "rtk"
allowlist = [
  "git status",
  "git diff",
  "git log",
  "git show",
  "git branch",
  "git rev-parse",
  "rg",
  "fd",
  "ls",
  "du",
  "wc",
  "cat",
  "head",
  "tail",
  "pytest",
  "cargo test",
  "npm test",
  "pnpm test",
  "bun test",
]
denylist = [
  "git add",
  "git commit",
  "git checkout",
  "git switch",
  "git merge",
  "git rebase",
  "git push",
  "git reset --hard",
  "git clean -fd",
  "rm -rf",
  "sudo",
  "ssh",
  "scp",
]
# Install contract: pinned URL + pinned sha256
install_url = ""
install_sha256 = ""
EOF
}

read_rtk_mode() {
  local rtk_file="$1"
  if ! command -v python3 >/dev/null 2>&1; then
    return
  fi

  python3 - "$rtk_file" <<'PY'
import sys
from pathlib import Path

try:
    import tomllib
except Exception:
    tomllib = None

path = Path(sys.argv[1])
if tomllib is None or not path.exists():
    raise SystemExit(0)

mode = ""
try:
    data = tomllib.loads(path.read_text(encoding="utf-8"))
    mode = str(data.get("mode", "")).strip().lower()
except Exception:
    mode = ""

if mode in {"on", "off"}:
    print(mode)
PY
}

ensure_rtk_config() {
  local rtk_file="$aoc_dir/rtk.toml"
  if [[ ! -f "$rtk_file" ]]; then
    write_default_rtk_config "$rtk_file"
    log "Seeded RTK routing config ($rtk_file, mode=on default)."
  else
    local existing_mode=""
    existing_mode="$(read_rtk_mode "$rtk_file" || true)"
    if [[ "$existing_mode" == "off" ]]; then
      log "RTK routing config exists with mode=off ($rtk_file). Preserving explicit disable."
    elif [[ "$existing_mode" == "on" ]]; then
      log "RTK routing config exists with mode=on ($rtk_file). Preserving."
    else
      log "RTK routing config exists ($rtk_file). Preserving."
    fi
  fi
}

ensure_git_tracking_policy() {
  local ignore_file="$project_root/.gitignore"
  local changed=0
  local line=""

  if [[ ! -f "$ignore_file" ]]; then
    log "Creating .gitignore..."
    : > "$ignore_file"
  fi

  if [[ -s "$ignore_file" ]]; then
    local last_char=""
    last_char="$(tail -c 1 "$ignore_file" 2>/dev/null || true)"
    if [[ "$last_char" != $'\n' ]]; then
      printf '\n' >> "$ignore_file"
    fi
  fi

  local rules=(
    "# AOC tracking policy (managed by aoc-init)"
    "!/.aoc/"
    "!/.aoc/**"
    "!/.taskmaster/"
    "!/.taskmaster/**"
  )

  for line in "${rules[@]}"; do
    if ! grep -Fqx "$line" "$ignore_file"; then
      printf '%s\n' "$line" >> "$ignore_file"
      changed=1
    fi
  done

  if [[ "$changed" == "1" ]]; then
    log "Updated .gitignore to keep .aoc/ and .taskmaster/ tracked."
  else
    log ".gitignore already keeps .aoc/ and .taskmaster/ tracked."
  fi
}

# 1. Setup Context & Memory (.aoc/)
setup_memory() {
  # Migration Logic
  if [[ -d "$gemini_dir" && ! -d "$aoc_dir" ]]; then
    log "Migrating .gemini/ to .aoc/..."
    mv "$gemini_dir" "$aoc_dir"
    if [[ -f "$aoc_dir/GEMINI.md" ]]; then
      mv "$aoc_dir/GEMINI.md" "$aoc_dir/context.md"
    fi
  fi

  if [[ ! -d "$aoc_dir" ]]; then
    log "Creating .aoc/ directory..."
    mkdir -p "$aoc_dir"
  fi

  # Memory File
  local mem_file="$aoc_dir/memory.md"
  if [[ ! -f "$mem_file" ]]; then
    log "Initializing empty memory ($mem_file)..."
    cat <<EOF > "$mem_file"
# Agent Memory for Project: $(basename "$project_root")
This file contains persistent context, decisions, and knowledge for the AI agent.
Agents should read this to understand project history and append new decisions here.

## Core Decisions
EOF
  else
    log "Memory file exists ($mem_file). Skipping."
  fi

  # Short-term memory workspace
  local stm_dir="$aoc_dir/stm"
  local stm_current="$stm_dir/current.md"
  local stm_archive="$stm_dir/archive"
  mkdir -p "$stm_archive"
  if [[ ! -f "$stm_current" ]]; then
    log "Initializing short-term memory ($stm_current)..."
    : > "$stm_current"
  else
    log "Short-term memory exists ($stm_current). Preserving."
  fi

  # Shared project layouts
  local layouts_dir="$aoc_dir/layouts"
  if [[ ! -d "$layouts_dir" ]]; then
    log "Creating shared layouts directory ($layouts_dir)..."
    mkdir -p "$layouts_dir"
  fi

  # AGENTS.md (project-level agent contract)
  local agents_file="$project_root/AGENTS.md"
  ensure_agents_contract "$agents_file"

  ensure_rtk_config

  # PI default prompt contract
  local prompts_dir="$aoc_dir/prompts"
  local pi_low_token_prompt="$prompts_dir/pi-low-token.md"
  if [[ ! -d "$prompts_dir" ]]; then
    log "Creating prompts directory ($prompts_dir)..."
    mkdir -p "$prompts_dir"
  fi
  if [[ ! -f "$pi_low_token_prompt" ]]; then
    log "Seeding PI low-token prompt ($pi_low_token_prompt)..."
    write_pi_low_token_prompt "$pi_low_token_prompt"
  else
    log "PI low-token prompt exists ($pi_low_token_prompt). Preserving."
  fi

  # Context Generation (project-specific, concise, full injection safe)
  local context_file="$aoc_dir/context.md"
  local context_tmp
  local context_line_budget
  local context_tree_depth
  local context_tree_line_budget
  local readme_heading_limit
  local project_name
  local current_branch="unknown"
  local tree_output=""
  local tree_lines=0
  local context_lines=0
  local readme_headings=""

  project_name="$(basename "$project_root")"
  context_tmp="$(mktemp)"
  context_line_budget="$(positive_int_or_default "${AOC_CONTEXT_LINE_BUDGET:-320}" 320)"
  context_tree_depth="$(positive_int_or_default "${AOC_CONTEXT_TREE_DEPTH:-2}" 2)"
  context_tree_line_budget="$(positive_int_or_default "${AOC_CONTEXT_TREE_LINE_BUDGET:-180}" 180)"
  readme_heading_limit="$(positive_int_or_default "${AOC_CONTEXT_README_HEADING_LIMIT:-40}" 40)"

  if command -v git >/dev/null 2>&1 && git -C "$project_root" rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    current_branch="$(git -C "$project_root" branch --show-current 2>/dev/null || true)"
    if [[ -z "$current_branch" ]]; then
      current_branch="$(git -C "$project_root" rev-parse --short HEAD 2>/dev/null || echo "detached")"
    fi
  fi

  if command -v tree >/dev/null 2>&1; then
    tree_output="$(tree -L "$context_tree_depth" --gitignore -I '.git|.taskmaster|.aoc|.gemini|node_modules|target|dist|archive|deprecated|.venv|venv|__pycache__' "$project_root" 2>/dev/null || true)"
    tree_lines="$(printf '%s\n' "$tree_output" | wc -l | tr -d ' ')"
  fi

  if [[ -f "$project_root/README.md" ]]; then
    readme_headings="$(grep -E '^#{1,6} ' "$project_root/README.md" | head -n "$readme_heading_limit" || true)"
  fi

  log "Generating/Updating Context ($context_file)..."

  {
    echo "# Project Context Snapshot"
    echo
    echo "## Repository"
    echo "- Name: $project_name"
    echo "- Root: $project_root"
    echo "- Git branch: $current_branch"

    echo
    echo "## Key Files"
    local found_key_file=0
    local key_file
    for key_file in \
      "README.md" \
      "Makefile" \
      "justfile" \
      "package.json" \
      "pnpm-lock.yaml" \
      "yarn.lock" \
      "bun.lockb" \
      "Cargo.toml" \
      "go.mod" \
      "pyproject.toml" \
      "requirements.txt" \
      "Dockerfile" \
      "docker-compose.yml" \
      "docker-compose.yaml"; do
      if [[ -f "$project_root/$key_file" ]]; then
        echo "- $key_file"
        found_key_file=1
      fi
    done
    if [[ "$found_key_file" == "0" ]]; then
      echo "- No common manifest files detected."
    fi

    echo
    echo "## Project Structure (tree -L $context_tree_depth)"
    echo '```'
    if [[ -n "$tree_output" ]]; then
      if (( tree_lines > context_tree_line_budget )); then
        printf '%s\n' "$tree_output" | head -n "$context_tree_line_budget"
        echo "... [tree truncated to ${context_tree_line_budget} lines]"
      else
        printf '%s\n' "$tree_output"
      fi
    else
      echo "tree command not found"
    fi
    echo '```'

    if [[ -n "$readme_headings" ]]; then
      echo
      echo "## README Headings"
      printf '%s\n' "$readme_headings"
    fi

    echo
    echo "## Current Task Tag"
    echo '```'
    if command -v tm >/dev/null 2>&1; then
      (cd "$project_root" && tm tag current 2>/dev/null || echo "unknown")
    elif command -v aoc-task >/dev/null 2>&1; then
      (cd "$project_root" && aoc-task tag current 2>/dev/null || echo "unknown")
    elif command -v aoc-cli >/dev/null 2>&1; then
      (cd "$project_root" && aoc-cli task tag current 2>/dev/null || echo "unknown")
    elif command -v task-master >/dev/null 2>&1; then
      echo "task-master does not expose current tag"
    else
      echo "Task command not found."
    fi
    echo '```'

    echo
    echo "## Active Workstreams (Tags)"
    echo '```'
    if command -v tm >/dev/null 2>&1; then
      (cd "$project_root" && tm tag list 2>/dev/null || echo "No tags found.")
    elif command -v aoc-task >/dev/null 2>&1; then
      (cd "$project_root" && aoc-task tag list 2>/dev/null || echo "No tags found.")
    elif command -v aoc-cli >/dev/null 2>&1; then
      (cd "$project_root" && aoc-cli task tag list 2>/dev/null || echo "No tags found.")
    elif command -v task-master >/dev/null 2>&1; then
      (cd "$project_root" && task-master tags 2>/dev/null || echo "No tags found.")
    else
      echo "Task command not found."
    fi
    echo '```'

    echo
    echo "## Task PRD Location"
    echo "- Directory: .taskmaster/docs/prds"
    echo "- Resolve tag PRD default with: aoc-task tag prd show --tag <tag>"
    echo "- Resolve task PRD override with: aoc-task prd show <id> --tag <tag>"
    echo "- Effective precedence: task PRD override -> tag PRD default"
  } > "$context_tmp"

  context_lines="$(wc -l < "$context_tmp" | tr -d ' ')"
  if (( context_lines > context_line_budget )); then
    {
      head -n "$context_line_budget" "$context_tmp"
      echo
      echo "... [context capped at ${context_line_budget} lines; adjust AOC_CONTEXT_LINE_BUDGET if needed]"
    } > "$context_file"
    rm -f "$context_tmp"
    log "Context exceeded budget (${context_lines} lines); wrote capped context (${context_line_budget} lines)."
  else
    mv "$context_tmp" "$context_file"
  fi

  # Setup .cursorrules symlink for universal agent awareness
  local cursor_rules="$project_root/.cursorrules"
  if [[ ! -e "$cursor_rules" ]]; then
    log "Creating .cursorrules symlink..."
    ln -s ".aoc/context.md" "$cursor_rules"
  elif [[ -L "$cursor_rules" ]]; then
    log "Existing .cursorrules symlink found. Skipping."
  else
    log "Existing .cursorrules file found. Skipping."
  fi

}

# 1b. Setup Skills (.aoc/skills)
setup_skills() {
  local skills_dir="$aoc_dir/skills"
  if [[ ! -d "$skills_dir" ]]; then
    log "Creating .aoc/skills directory..."
    mkdir -p "$skills_dir"
  fi

  local seed_dir=""
  local candidate=""
  local seed_has_skills=0
  local seed_dirs=()
  local skill_list=()
  local disable_default_seeding=0
  local seed_toggle="${AOC_INIT_SEED_DEFAULT_SKILLS:-}"
  local no_seed_file="$skills_dir/.aoc-no-default-seed"

  if [[ -f "$no_seed_file" ]]; then
    disable_default_seeding=1
    log "Default skill seeding disabled by marker: .aoc/skills/.aoc-no-default-seed"
  fi

  if [[ -n "$seed_toggle" ]]; then
    case "${seed_toggle,,}" in
      0|false|no|off)
        disable_default_seeding=1
        log "Default skill seeding disabled by AOC_INIT_SEED_DEFAULT_SKILLS=$seed_toggle"
        ;;
      1|true|yes|on)
        disable_default_seeding=0
        log "Default skill seeding enabled by AOC_INIT_SEED_DEFAULT_SKILLS=$seed_toggle"
        ;;
      *)
        warn "Unrecognized AOC_INIT_SEED_DEFAULT_SKILLS='$seed_toggle' (expected true/false); keeping current behavior."
        ;;
    esac
  fi

  if [[ "$disable_default_seeding" != "1" ]]; then
    for candidate in "$aoc_config_dir/skills" "$script_dir/../.aoc/skills"; do
      if [[ -d "$candidate" ]]; then
        shopt -s nullglob
        skill_list=("$candidate"/*/SKILL.md)
        shopt -u nullglob
        if ((${#skill_list[@]} > 0)); then
          seed_dirs+=("$candidate")
          seed_has_skills=1
        fi
      fi
    done

    if [[ "$seed_has_skills" == "1" ]]; then
      local copied=0
      local entry=""
      for seed_dir in "${seed_dirs[@]}"; do
        shopt -s nullglob
        local seed_entries=("$seed_dir"/*)
        shopt -u nullglob
        for entry in "${seed_entries[@]}"; do
          [[ -d "$entry" ]] || continue
          local name
          name="$(basename "$entry")"
          if [[ ! -e "$skills_dir/$name" ]]; then
            cp -R "$entry" "$skills_dir/$name"
            copied=1
          fi
        done
        if [[ -f "$seed_dir/manifest.toml" && ! -f "$skills_dir/manifest.toml" ]]; then
          cp "$seed_dir/manifest.toml" "$skills_dir/manifest.toml"
          copied=1
        fi
      done
      if [[ "$copied" == "1" ]]; then
        log "Seeded AOC skills into .aoc/skills."
      fi
    else
      warn "No default skills source found; leaving .aoc/skills as-is."
    fi
  else
    log "Skipping default skill seeding; preserving curated .aoc/skills."
  fi

  upgrade_stm_skill_guidance "$skills_dir"

  if [[ -x "$script_dir/aoc-skill" ]]; then
    log "Syncing skills for active agent..."
    (cd "$project_root" && "$script_dir/aoc-skill" sync --active --root "$project_root" || true)
    log "Syncing skills for existing agent targets..."
    (cd "$project_root" && "$script_dir/aoc-skill" sync --existing --root "$project_root" || true)
  elif command -v aoc-skill >/dev/null 2>&1; then
    log "Syncing skills for active agent..."
    (cd "$project_root" && aoc-skill sync --active --root "$project_root" || true)
    log "Syncing skills for existing agent targets..."
    (cd "$project_root" && aoc-skill sync --existing --root "$project_root" || true)
  fi
}

upgrade_stm_skill_guidance() {
  local skills_dir="$1"
  local stm_skill="$skills_dir/stm-ops/SKILL.md"
  local memory_skill="$skills_dir/memory-ops/SKILL.md"
  local workflow_skill="$skills_dir/aoc-workflow/SKILL.md"
  local init_ops_skill="$skills_dir/aoc-init-ops/SKILL.md"

  if [[ -f "$stm_skill" ]] && (
    grep -Fq 'aoc-stm --last' "$stm_skill" ||
    grep -Fq 'aoc-stm use <archive>' "$stm_skill" ||
    grep -Fq 'fresh tab/session' "$stm_skill" ||
    grep -Fq 'aoc-stm handoff` (read current draft, fallback to latest archive)' "$stm_skill" ||
    ! grep -Fq 'aoc-stm resume' "$stm_skill"
  ); then
    cat <<'EOF' > "$stm_skill"
---
name: stm-ops
description: Capture and read short-term diary context with aoc-stm.
---

## When to use
- Context window is getting tight and you need to summarize current execution state.
- You need to load current draft STM context into the terminal transcript.

## Commands
- `aoc-stm add "<note>"`
- `aoc-stm edit`
- `aoc-stm` (default read current draft)
- `aoc-stm read-current`
- `aoc-stm handoff` (archive current draft and print handoff snapshot)
- `aoc-stm resume` (read archived handoff snapshot; latest by default)
- `aoc-stm archive`
- `aoc-stm read` (read latest archive)
- `aoc-stm history`
- `aoc-stm read <archive>`

## Handoff format (recommended)
- Objective and task/subtask IDs
- Done / in-progress / blocked
- Files touched and key command outcomes
- Open decisions + assumptions
- Next 3-5 concrete steps

## Guardrails
- Keep STM as a project diary: write/edit in current draft via `aoc-stm`, then seal clean checkpoints with `aoc-stm handoff`.
- Promote durable decisions to `aoc-mem add`, not STM.
- Do not edit `tasks.json` directly while preparing handoff state.
EOF
    log "Updated stm-ops skill with draft-seal-resume STM guidance."
  fi

  if [[ -f "$memory_skill" ]] && (
    grep -Fq 'aoc-stm handoff` (read current draft, fallback to latest archive)' "$memory_skill" ||
    ! grep -Fq 'aoc-stm resume' "$memory_skill"
  ); then
    cat <<'EOF' > "$memory_skill"
---
name: memory-ops
description: Use aoc-mem to read, search, and record project decisions.
---

## Commands
- `aoc-mem read`
- `aoc-mem search "<term>"`
- `aoc-mem add "<decision>"`
- `aoc-stm add "<handoff note>"`
- `aoc-stm edit`
- `aoc-stm` (read current draft)
- `aoc-stm handoff` (archive current draft and print handoff snapshot)
- `aoc-stm resume` (read archived handoff snapshot; latest by default)
- `aoc-stm archive`
- `aoc-stm read` (read latest archive)
- `aoc-stm history`

## Recording guidelines
- Capture the "why" behind decisions.
- Keep entries short and scoped.
- Record one decision per line.

## Guardrail
- Never edit `.aoc/memory.md` directly.
- Keep `.aoc/stm/current.md` as an in-progress draft and archive it often so STM becomes a durable project diary.
EOF
    log "Updated memory-ops skill with STM command guidance."
  fi

  if [[ -f "$workflow_skill" ]] && (
    grep -Fq 'aoc task list' "$workflow_skill" ||
    grep -Fq 'aoc task add' "$workflow_skill" ||
    grep -Fq 'aoc task status' "$workflow_skill" ||
    grep -Fq 'review current draft with `aoc-stm`' "$workflow_skill" ||
    ! grep -Fq 'aoc-stm resume' "$workflow_skill"
  ); then
    cat <<'EOF' > "$workflow_skill"
---
name: aoc-workflow
description: Standard AOC workflow using context, memory, and tasks.
---

## When to use
Use this when you start a new task or need to re-orient inside a project.

## Steps
1. If AOC files are missing or stale, run `aoc-init` from the project root.
2. Read memory: `aoc-mem read` and `aoc-mem search "<topic>"` as needed.
3. Resolve active tag at session start with `tm tag current` (or `aoc-task tag current`).
4. Review tasks: `tm list`, `aoc-task list`, or the Taskmaster TUI.
5. Check PRD linkage for scope and task:
   - Tag default: `aoc-task tag prd show --tag <tag>`
   - Task override: `aoc-task prd show <id> --tag <tag>`
6. Plan: add or refine tasks with `aoc-task add "<task>"` and set status.
7. Execute changes and run tests.
8. If context gets tight, capture state (`aoc-stm add/edit`; in OpenCode you can run `/stm`), seal a clean checkpoint with `aoc-stm handoff`, and use `aoc-stm resume` (or `aoc-stm read`) to load resumable archived context in a new session.
9. Update tasks and record decisions: `aoc-task status <id> done`, `aoc-mem add "<decision>"`.

## Guardrails
- Do not edit `.aoc/memory.md` directly.
- Do not keep long-term decisions in `.aoc/stm/current.md`; promote durable decisions to `aoc-mem`.
- Do not edit `.taskmaster/tasks/tasks.json` directly.
- Do not add PRD links to subtasks.
- Use tag-level PRD defaults with task-level overrides (`aocPrd`), with precedence task -> tag.
EOF
    log "Updated aoc-workflow skill with draft-seal-resume STM guidance."
  fi

  if [[ -f "$init_ops_skill" ]] && (
    ! grep -Fq '.aoc/stm/current.md' "$init_ops_skill" ||
    ! grep -Fq 'OpenCode `/stm` command' "$init_ops_skill" ||
    ! grep -Fq 'aoc-stm handoff' "$init_ops_skill" ||
    ! grep -Fq 'aoc-stm resume' "$init_ops_skill"
  ); then
    cat <<'EOF' > "$init_ops_skill"
---
name: aoc-init-ops
description: Initialize or repair AOC context, memory, and tasks safely.
---

## When to use
- New repository setup
- Missing `.aoc/` or `.taskmaster/`
- Stale or inconsistent context

## Run
- `aoc-init`
- To skip Rust builds: `AOC_INIT_SKIP_BUILD=1 aoc-init`

## What it does
- Creates `.aoc/` and `.taskmaster/` if missing
- Generates `.aoc/context.md`
- Seeds `.aoc/memory.md`
- Seeds `.aoc/stm/current.md` and `.aoc/stm/archive/` without overwriting existing STM files
- Ensures PRD directory `.taskmaster/docs/prds/` is available for tag/task links
- Seeds OpenCode `/stm` command in `.opencode/commands/stm.md` when missing and keeps STM guidance aligned (`aoc-stm` = current draft, `aoc-stm handoff` = seal+print handoff, `aoc-stm resume` = archived resume)
- Seeds OpenCode `/prd` command in `.opencode/commands/prd.md` when missing
- Seeds OpenCode teach-mode subagent/commands (`@teach`, `/teach-full`, `/teach-dive`, `/teach-ask`) when missing
- Syncs skills for existing agent targets
EOF
    log "Updated aoc-init-ops skill with STM seeding guidance."
  fi
}

# 1c. Setup OpenCode Agents (.opencode/agents)
setup_agents() {
  local opencode_agents_dir="$project_root/.opencode/agents"
  local seed_file=""
  local candidate=""

  for candidate in \
    "$aoc_config_dir/agents/opencode/aoc-ops.md" \
    "$script_dir/../.aoc/agents/opencode/aoc-ops.md"; do
    if [[ -f "$candidate" ]]; then
      seed_file="$candidate"
      break
    fi
  done

  if [[ -z "$seed_file" ]]; then
    warn "No OpenCode agent template found; skipping agent seeding."
    return
  fi

  if [[ ! -d "$opencode_agents_dir" ]]; then
    mkdir -p "$opencode_agents_dir"
  fi

  local agent_file="$opencode_agents_dir/aoc-ops.md"

  if [[ ! -f "$agent_file" ]]; then
    cp "$seed_file" "$agent_file"
    log "Seeded OpenCode agent: aoc-ops"
  else
    local updated_agent=0
    if grep -Fq '.aoc/themes/' "$agent_file" || grep -Fq 'Prefer project themes over global themes when names overlap.' "$agent_file"; then
      python3 - "$agent_file" <<'PY'
from pathlib import Path
import sys

path = Path(sys.argv[1])
text = path.read_text(encoding="utf-8")
updated = text.replace(
    "- Managing custom Zellij themes with `aoc-theme` (`tui`, `presets`, and manual) for global (`~/.config/zellij/themes/`) and project (`.aoc/themes/`) scopes.",
    "- Managing custom Zellij themes with `aoc-theme` (`tui`, `presets`, and manual) in global scope (`~/.config/zellij/themes/`).",
)
updated = updated.replace(
    "- Prefer project themes over global themes when names overlap.",
    "- Use global themes only (Zellij theme selection is session-wide).",
)
if updated != text:
    path.write_text(updated, encoding="utf-8")
PY
      log "Updated OpenCode agent with global-only theme guidance."
      updated_agent=1
    fi
    if ! grep -Fq '.aoc/layouts/' "$agent_file"; then
      cat <<'EOF' >> "$agent_file"

## Layout Operations
- Manage project-shared layouts in `.aoc/layouts/`.
- Prefer `.aoc/layouts/<name>.kdl` over `~/.config/zellij/layouts/<name>.kdl` when names overlap.
- Validate layouts via `aoc-layout --tab <name>`.
EOF
      log "Updated OpenCode agent with project layout guidance."
      updated_agent=1
    fi
    if ! grep -Fq 'aoc-theme' "$agent_file"; then
      cat <<'EOF' >> "$agent_file"

## Theme Operations
- Manage global themes in `~/.config/zellij/themes/`.
- Use `aoc-theme tui` for interactive selection (preset + custom sections).
- Use `aoc-theme apply --name <theme>` for live apply and `aoc-theme set-default --name <theme>` to persist.
EOF
      log "Updated OpenCode agent with theme guidance."
      updated_agent=1
    fi
    if [[ "$updated_agent" == "0" ]]; then
      log "OpenCode agent already present. Preserving."
    fi
  fi

  local teach_seed=""
  for candidate in \
    "$aoc_config_dir/agents/opencode/teach.md" \
    "$script_dir/../.aoc/agents/opencode/teach.md"; do
    if [[ -f "$candidate" ]]; then
      teach_seed="$candidate"
      break
    fi
  done

  if [[ -n "$teach_seed" ]]; then
    local teach_agent_file="$opencode_agents_dir/teach.md"
    if [[ ! -f "$teach_agent_file" ]]; then
      cp "$teach_seed" "$teach_agent_file"
      log "Seeded OpenCode agent: teach"
    else
      log "OpenCode agent @teach already present. Preserving."
    fi
  fi
}

# 1d. Setup OpenCode Commands (.opencode/commands)
setup_opencode_commands() {
  local opencode_commands_dir="$project_root/.opencode/commands"
  local candidate=""
  local commands_seed_dirs=(
    "$aoc_config_dir/commands/opencode"
    "$script_dir/../.aoc/commands/opencode"
  )

  if [[ ! -d "$opencode_commands_dir" ]]; then
    mkdir -p "$opencode_commands_dir"
  fi

  local seeded_any=0
  local seed_file=""
  local target_file=""
  for candidate in "${commands_seed_dirs[@]}"; do
    [[ -d "$candidate" ]] || continue
    shopt -s nullglob
    for seed_file in "$candidate"/*.md; do
      target_file="$opencode_commands_dir/$(basename "$seed_file")"
      if [[ ! -f "$target_file" ]]; then
        cp "$seed_file" "$target_file"
        log "Seeded OpenCode command: /$(basename "$seed_file" .md)"
      else
        if [[ "$(basename "$target_file")" == "stm.md" ]] && (
          grep -Fq 'default `--last`) to archive and continue in a fresh tab/session with STM injected.' "$target_file" ||
          grep -Fq 'then `aoc-stm` to print the latest archived STM context into the transcript.' "$target_file" ||
          grep -Fq 'then `aoc-stm` to print the latest archived STM context into the terminal transcript.' "$target_file" ||
          grep -Fq 'aoc-stm archive` persists this snapshot, and `aoc-stm read` prints the latest archived STM context into the terminal transcript.' "$target_file" ||
          grep -Fq 'aoc-stm handoff` prints current draft with archive fallback for fast resume.' "$target_file" ||
          ! grep -Fq 'aoc-stm resume' "$target_file"
        ); then
          python3 - "$target_file" <<'PY'
from pathlib import Path
import re
import sys

path = Path(sys.argv[1])
text = path.read_text(encoding="utf-8")
updated = text
legacy_lines = [
    "When finished, remind me I can run `aoc-stm` (default `--last`) to archive and continue in a fresh tab/session with STM injected.",
    "When finished, remind me to run `aoc-stm archive` to persist this snapshot, then `aoc-stm` to print the latest archived STM context into the transcript.",
    "When finished, remind me to run `aoc-stm archive` to persist this snapshot, then `aoc-stm` to print the latest archived STM context into the terminal transcript.",
    "When finished, remind me that `aoc-stm` reads the current draft, `aoc-stm archive` persists this snapshot, and `aoc-stm read` prints the latest archived STM context into the terminal transcript.",
    "When finished, remind me that `aoc-stm` reads the current draft, `aoc-stm archive` persists this snapshot, `aoc-stm read` prints the latest archived STM context, and `aoc-stm handoff` prints current draft with archive fallback for fast resume.",
]
new_line = "When finished, remind me that `aoc-stm` reads the current draft, `aoc-stm handoff` archives the draft and prints the handoff snapshot, and `aoc-stm resume` (or `aoc-stm read`) loads archived resume context in a new session."

for line in legacy_lines:
    updated = updated.replace(line, new_line)

if "aoc-stm resume" not in updated:
    updated = re.sub(r"When finished, remind me[^\n]*", new_line, updated, count=1)

if updated != text:
    path.write_text(updated, encoding="utf-8")
PY
          log "Updated OpenCode command /stm with draft-seal-resume STM guidance."
        fi
        log "OpenCode command /$(basename "$seed_file" .md) already present. Preserving."
      fi
      seeded_any=1
    done
    shopt -u nullglob
  done

  if [[ "$seeded_any" != "1" ]]; then
    warn "No OpenCode command templates found; skipping command seeding."
  fi
}

# 2. Setup Taskmaster (.taskmaster/)
setup_tasks() {
  log "Initializing Taskmaster..."

  mkdir -p "$task_dir/tasks" "$task_dir/docs/prds" "$task_dir/reports" "$task_dir/templates"

  local native_init_ok=0
  if command -v aoc-task >/dev/null 2>&1; then
    if (cd "$project_root" && aoc-task init >/dev/null 2>&1); then
      native_init_ok=1
    else
      warn "aoc-task init failed; using shell fallback for task scaffolding."
    fi
  elif command -v aoc-cli >/dev/null 2>&1; then
    if (cd "$project_root" && aoc-cli task init >/dev/null 2>&1); then
      native_init_ok=1
    else
      warn "aoc-cli task init failed; using shell fallback for task scaffolding."
    fi
  fi

  if [[ "$native_init_ok" != "1" ]]; then
    if [[ ! -f "$task_dir/tasks/tasks.json" ]]; then
      cat <<EOF > "$task_dir/tasks/tasks.json"
{
  "master": {
    "tasks": []
  }
}
EOF
    fi

    if [[ ! -f "$task_dir/state.json" ]]; then
      now_stamp="$(date -u +%Y-%m-%dT%H:%M:%S.%3NZ)"
      cat <<EOF > "$task_dir/state.json"
{
  "currentTag": "master",
  "lastUpdated": "${now_stamp}",
  "lastSwitched": "${now_stamp}",
  "branchTagMapping": {},
  "migrationNoticeShown": true
}
EOF
    fi
  fi

  local template_name=""
  local template_src=""
  local candidate=""
  local template_candidates=(
    "$aoc_config_dir/taskmaster/templates"
    "$script_dir/../.taskmaster/templates"
  )

  for template_name in "example_prd.txt" "example_prd_rpg.txt"; do
    if [[ -f "$task_dir/templates/$template_name" ]]; then
      continue
    fi
    template_src=""
    for candidate in "${template_candidates[@]}"; do
      if [[ -f "$candidate/$template_name" ]]; then
        template_src="$candidate/$template_name"
        break
      fi
    done
    if [[ -n "$template_src" ]]; then
      cp "$template_src" "$task_dir/templates/$template_name"
      log "Seeded Taskmaster template: $task_dir/templates/$template_name"
    else
      warn "No upstream template found for $template_name."
    fi
  done

  local project_prd="$task_dir/docs/prd.md"
  if [[ ! -f "$project_prd" ]]; then
    if [[ -f "$task_dir/templates/example_prd.txt" ]]; then
      cp "$task_dir/templates/example_prd.txt" "$project_prd"
      log "Seeded project PRD from upstream template: $project_prd"
    else
      cat <<'EOF' > "$project_prd"
# Product Requirements Document

## Problem
Describe the core user problem this project solves.

## Goals
-

## Non-Goals
-

## User Stories
- As a <user>, I want <capability> so that <outcome>.

## Requirements
-

## Acceptance Criteria
- [ ]

## Constraints
-

## Risks
-

## Test Strategy
-
EOF
      log "Seeded fallback project PRD template: $project_prd"
    fi
  fi

  local project_prd_txt="$task_dir/docs/prd.txt"
  if [[ -f "$project_prd" && ! -f "$project_prd_txt" ]]; then
    cp "$project_prd" "$project_prd_txt"
    log "Seeded Taskmaster-compatible project PRD copy: $project_prd_txt"
  fi

  # Config Seeding (Preserve existing logic, but ensure Gemini preference)
  local local_conf="$task_dir/config.json"
  
  if [[ -f "$global_task_conf" ]]; then
    if [[ ! -f "$local_conf" ]]; then
      log "Seeding Taskmaster config from global defaults..."
      cp "$global_task_conf" "$local_conf"
    else
      # Advanced: We could merge JSON here, but for now we trust the local config
      # if it exists, assuming the user might have customized it for this specific repo.
      log "Local Taskmaster config exists. Preserving."
    fi
  else
    warn "No global Taskmaster config found at $global_task_conf. Skipping seed."
  fi
}

# 3. Environment Checks
setup_env() {
  if [[ ! -f "$project_root/.env" && -f "$project_root/.env.example" ]]; then
    log "Copying .env.example to .env..."
    cp "$project_root/.env.example" "$project_root/.env"
  fi
}

# 4. Ensure AOC Rust binaries are available
setup_binaries() {
  if [[ "${AOC_INIT_SKIP_BUILD:-0}" == "1" ]]; then
    log "Skipping Rust binary build (AOC_INIT_SKIP_BUILD=1)."
    return
  fi

  local manifest_path=""
  if [[ -f "$project_root/crates/Cargo.toml" ]]; then
    manifest_path="$project_root/crates/Cargo.toml"
  elif [[ -f "$script_dir/../crates/Cargo.toml" ]]; then
    manifest_path="$script_dir/../crates/Cargo.toml"
  fi

  local required=(aoc-hub-rs aoc-agent-wrap-rs aoc-mission-control aoc-taskmaster aoc-control)
  local missing=()
  local bin=""
  local manifest_dir=""
  if [[ -n "$manifest_path" ]]; then
    manifest_dir="$(dirname "$manifest_path")"
  fi

  for bin in "${required[@]}"; do
    if command -v "$bin" >/dev/null 2>&1; then
      continue
    fi
    if [[ -n "$manifest_dir" ]]; then
      if [[ -x "$manifest_dir/target/release/$bin" || -x "$manifest_dir/target/debug/$bin" ]]; then
        continue
      fi
    fi
    missing+=("$bin")
  done

  if ((${#missing[@]} == 0)); then
    log "Rust binaries already available. Skipping build."
    return
  fi

  if [[ -z "$manifest_path" ]]; then
    warn "Rust workspace not found. Missing binaries: ${missing[*]}"
    return
  fi

  if ! command -v cargo >/dev/null 2>&1; then
    warn "cargo not found; unable to build binaries: ${missing[*]}"
    return
  fi

  log "Building AOC Rust binaries: ${required[*]}"
  cargo build --manifest-path "$manifest_path" -p aoc-hub-rs -p aoc-agent-wrap-rs -p aoc-mission-control -p aoc-taskmaster -p aoc-control
}

main() {
  log "Initializing AOC in: $project_root"
  setup_memory
  setup_skills
  setup_agents
  setup_opencode_commands
  setup_tasks
  ensure_git_tracking_policy
  setup_env
  setup_binaries
  log "AOC Initialization Complete. Ready to launch."
}

main
