#!/usr/bin/env bash
set -euo pipefail

# AOC Initialization Script
# Usage: aoc-init [path]
#
# This script standardizes a project for the Agent Ops Cockpit.
# It is IDEMPOTENT: safe to run multiple times. It respects existing data.

project_root="${1:-$PWD}"
aoc_dir="$project_root/.aoc"
gemini_dir="$project_root/.gemini"
task_dir="$project_root/.taskmaster"
global_task_conf="$HOME/.taskmaster/config.json"
aoc_config_dir="${XDG_CONFIG_HOME:-$HOME/.config}/aoc"
script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

log() { echo ">> $1"; }
warn() { echo "!! $1"; }

# 1. Setup Context & Memory (.aoc/)
setup_memory() {
  # Migration Logic
  if [[ -d "$gemini_dir" && ! -d "$aoc_dir" ]]; then
    log "Migrating .gemini/ to .aoc/..."
    mv "$gemini_dir" "$aoc_dir"
    if [[ -f "$aoc_dir/GEMINI.md" ]]; then
      mv "$aoc_dir/GEMINI.md" "$aoc_dir/context.md"
    fi
  fi

  if [[ ! -d "$aoc_dir" ]]; then
    log "Creating .aoc/ directory..."
    mkdir -p "$aoc_dir"
  fi

  # Memory File
  local mem_file="$aoc_dir/memory.md"
  if [[ ! -f "$mem_file" ]]; then
    log "Initializing empty memory ($mem_file)..."
    cat <<EOF > "$mem_file"
# Agent Memory for Project: $(basename "$project_root")
This file contains persistent context, decisions, and knowledge for the AI agent.
Agents should read this to understand project history and append new decisions here.

## Core Decisions
EOF
  else
    log "Memory file exists ($mem_file). Skipping."
  fi

  # Short-term memory workspace
  local stm_dir="$aoc_dir/stm"
  local stm_current="$stm_dir/current.md"
  local stm_archive="$stm_dir/archive"
  mkdir -p "$stm_archive"
  if [[ ! -f "$stm_current" ]]; then
    log "Initializing short-term memory ($stm_current)..."
    : > "$stm_current"
  else
    log "Short-term memory exists ($stm_current). Preserving."
  fi

  # AGENTS.md (project-level agent contract)
  local agents_file="$project_root/AGENTS.md"
  if [[ ! -f "$agents_file" ]]; then
    log "Creating AGENTS.md..."
    cat <<'EOF' > "$agents_file"
# AOC Architecture & Agent Guidelines

This file defines the always-on rules for agents in this repo. Procedural playbooks live in AOC skills.

## Always-on rules
- Use `.aoc/context.md` for orientation; run `aoc-init` if it is missing or stale.
- `.aoc/memory.md` is append-only; use `aoc-mem` to read/search/add. Do not edit the file directly.
- `.aoc/stm/current.md` is short-term working state; use `aoc-stm` to add/edit/handoff/archive. Do not store long-term decisions here.
- `.taskmaster/tasks/tasks.json` is task state; use the Taskmaster TUI or `aoc-task` commands. Do not edit the file directly.
- Task PRDs are linked per task (not subtask) via `aocPrd`; keep PRD documents in `.taskmaster/docs/prds/` and resolve via `aoc-task prd` commands.
- Record major decisions and constraints in memory (`aoc-mem add "..."`).

## Core files
- `.aoc/context.md`: auto-generated project snapshot.
- `.aoc/memory.md`: persistent decision log.
- `.aoc/stm/current.md`: ephemeral short-term handoff state.
- `.aoc/stm/archive/`: archived STM snapshots used for handoffs/history.
- `.taskmaster/tasks/tasks.json`: dynamic task queue.
- `.taskmaster/docs/prds/`: task-level PRD documents linked from tasks.

## Skills (load when needed)
- `aoc-workflow`: standard project workflow.
- `aoc-init-ops`: initialize or repair AOC files.
- `memory-ops`: read/search/add to memory.
- `stm-ops`: manage short-term handoff memory and resume flow.
- `taskmaster-ops`: manage tasks and tags.
- `rlm-analysis`: large codebase analysis flow.
- `prd-dev`: draft the Taskmaster PRD.
- `prd-intake`: parse a project PRD into actionable tasks.
- `prd-align`: align tasks with the PRD.
- `tag-align`: normalize task tags and dependencies.
- `task-breakdown`: expand tasks into subtasks.
- `task-checker`: verify implementation vs. testStrategy.
- `release-notes`: draft changelog and release notes.
- `skill-creator`: create or update AOC skills.
EOF
  else
    if grep -Eq "AOC Architecture & Agent Guidelines|Agent Ops Cockpit \(AOC\)" "$agents_file"; then
      if grep -Eq "Skills \(load when needed\)|aoc-workflow" "$agents_file"; then
        log "AGENTS.md already includes AOC guidance. Skipping."
      else
        log "Appending AOC skills guidance to AGENTS.md..."
        cat <<'EOF' >> "$agents_file"

## Skills (load when needed)
- `aoc-workflow`: standard project workflow.
- `aoc-init-ops`: initialize or repair AOC files.
- `memory-ops`: read/search/add to memory.
- `stm-ops`: manage short-term handoff memory and resume flow.
- `taskmaster-ops`: manage tasks and tags.
- `rlm-analysis`: large codebase analysis flow.
- `prd-dev`: draft the Taskmaster PRD.
- `prd-intake`: parse a project PRD into actionable tasks.
- `prd-align`: align tasks with the PRD.
- `tag-align`: normalize task tags and dependencies.
- `task-breakdown`: expand tasks into subtasks.
- `task-checker`: verify implementation vs. testStrategy.
- `release-notes`: draft changelog and release notes.
- `skill-creator`: create or update AOC skills.
EOF
      fi
    else
      log "Appending AOC agent guidance to AGENTS.md..."
      cat <<'EOF' >> "$agents_file"

## Agent Ops Cockpit (AOC)
Use the AOC tools for context, memory, and tasks in this repo.

- **Context:** `.aoc/context.md` (read-only)
- **Memory:** `.aoc/memory.md` via `aoc-mem read/add` (do not edit directly)
- **Short-term memory:** `.aoc/stm/current.md` via `aoc-stm` (ephemeral handoff state)
- **Tasks:** `.taskmaster/tasks/tasks.json` via `aoc-task list/add/status` (do not edit directly)
- **Task PRDs:** `.taskmaster/docs/prds/` linked with `aoc-task prd` (task-level only, no subtask PRDs)
- **Skills:** load AOC skills as needed for workflows

If the AOC files are missing, run `aoc-init` at the repo root.
EOF
    fi
  fi

  # Context Generation (context.md)
  local context_file="$aoc_dir/context.md"
  log "Generating/Updating Context ($context_file)..."
  
  # Start with header
  cat <<EOF > "$context_file"
# Agent Ops Cockpit (AOC) Global Context

## Core Philosophy
This machine uses the **Agent Ops Cockpit (AOC)** system. All agents (Gemini, Claude, OpenCode) running here share a unified set of tools for **Memory** and **Task Management**.

## 1. Project Structure
\`\`\`
$(tree -L 2 --gitignore -I '.git|.taskmaster|.aoc|.gemini|node_modules|target|dist|archive|deprecated' "$project_root" || echo "tree command not found")
\`\`\`

## 2. Long-Term Memory (\`aoc-mem\`)
**Purpose:** Persistent storage of architectural decisions.
**Commands:** \`aoc-mem read\`, \`aoc-mem add "fact"\`.

## 3. Short-Term Memory (\`aoc-stm\`)
**Purpose:** Ephemeral handoff state for context-window continuation.
**Commands:** \`aoc-stm add "note"\`, \`aoc-stm --last\`, \`aoc-stm history\`.

## 4. Task Management (\`aoc-task\`)
**Purpose:** Granular tracking of work.
**Commands:** \`aoc-task list\`, \`aoc-task add "Task"\`.

## 5. Operational Rules
- **No Amnesia:** Always check \`aoc-mem\` first.
- **No Ghost Work:** Track all work in \`aoc-task\` (or \`task-master\`).
EOF
  
  # Append README if it exists
  if [[ -f "$project_root/README.md" ]]; then
    echo >> "$context_file"
    echo "## 6. README Content" >> "$context_file"
    cat "$project_root/README.md" >> "$context_file"
  fi

  # Append Taskmaster Tags if available
  if command -v aoc-task >/dev/null 2>&1 || command -v aoc-cli >/dev/null 2>&1 || command -v task-master >/dev/null 2>&1; then
    echo >> "$context_file"
    echo "## 7. Active Workstreams (Tags)" >> "$context_file"
    # Run in subshell to preserve cwd, capture output
    if command -v aoc-task >/dev/null 2>&1; then
      tags_output="$(cd "$project_root" && aoc-task tag list 2>/dev/null || echo "No tags found.")"
    elif command -v aoc-cli >/dev/null 2>&1; then
      tags_output="$(cd "$project_root" && aoc-cli task tag list 2>/dev/null || echo "No tags found.")"
    else
      tags_output="$(cd "$project_root" && task-master tags 2>/dev/null || echo "No tags found.")"
    fi
    echo "\`\`\`" >> "$context_file"
    echo "$tags_output" >> "$context_file"
    echo "\`\`\`" >> "$context_file"
  fi

  # Setup .cursorrules symlink for universal agent awareness
  local cursor_rules="$project_root/.cursorrules"
  if [[ ! -e "$cursor_rules" ]]; then
    log "Creating .cursorrules symlink..."
    ln -s ".aoc/context.md" "$cursor_rules"
  elif [[ -L "$cursor_rules" ]]; then
    log "Existing .cursorrules symlink found. Skipping."
  else
    log "Existing .cursorrules file found. Skipping."
  fi

  # Update context with RLM Protocol if aoc-rlm is available
  if command -v aoc-rlm >/dev/null 2>&1 || [[ -x "$project_root/bin/aoc-rlm" ]]; then
    log "Adding RLM Protocol to context..."
    cat <<EOF >> "$context_file"

## 8. RLM Skill (Large Codebase Analysis)
When you need to analyze more files than fit in your context:
1. **Scan:** Run \`aoc-rlm scan\` (or \`rlm scan\`) to see the scale of the codebase.
2. **Peek:** Run \`aoc-rlm peek "search_term"\` (or \`rlm peek\`) to find relevant snippets and file paths.
3. **Slice:** Run \`aoc-rlm chunk --pattern "src/relevant/*.rs"\` (or \`rlm chunk\`) to get JSON chunks.
4. **Process:** Use your available sub-agent tools (like \`Task\`) to process chunks in parallel.
5. **Reduce:** Synthesize the sub-agent outputs into a final answer.
EOF
  fi
}

# 1b. Setup Skills (.aoc/skills)
setup_skills() {
  local skills_dir="$aoc_dir/skills"
  if [[ ! -d "$skills_dir" ]]; then
    log "Creating .aoc/skills directory..."
    mkdir -p "$skills_dir"
  fi

  local seed_dir=""
  local candidate=""
  local seed_has_skills=0
  local seed_dirs=()
  local skill_list=()

  for candidate in "$aoc_config_dir/skills" "$script_dir/../.aoc/skills"; do
    if [[ -d "$candidate" ]]; then
      shopt -s nullglob
      skill_list=("$candidate"/*/SKILL.md)
      shopt -u nullglob
      if ((${#skill_list[@]} > 0)); then
        seed_dirs+=("$candidate")
        seed_has_skills=1
      fi
    fi
  done

  if [[ "$seed_has_skills" == "1" ]]; then
    local copied=0
    local entry=""
    for seed_dir in "${seed_dirs[@]}"; do
      shopt -s nullglob
      local seed_entries=("$seed_dir"/*)
      shopt -u nullglob
      for entry in "${seed_entries[@]}"; do
        [[ -d "$entry" ]] || continue
        local name
        name="$(basename "$entry")"
        if [[ ! -e "$skills_dir/$name" ]]; then
          cp -R "$entry" "$skills_dir/$name"
          copied=1
        fi
      done
      if [[ -f "$seed_dir/manifest.toml" && ! -f "$skills_dir/manifest.toml" ]]; then
        cp "$seed_dir/manifest.toml" "$skills_dir/manifest.toml"
        copied=1
      fi
    done
    if [[ "$copied" == "1" ]]; then
      log "Seeded AOC skills into .aoc/skills."
    fi
  else
    warn "No default skills source found; leaving .aoc/skills as-is."
  fi

  if [[ -x "$script_dir/aoc-skill" ]]; then
    log "Syncing skills for active agent..."
    (cd "$project_root" && "$script_dir/aoc-skill" sync --active --root "$project_root" || true)
    log "Syncing skills for existing agent targets..."
    (cd "$project_root" && "$script_dir/aoc-skill" sync --existing --root "$project_root" || true)
  elif command -v aoc-skill >/dev/null 2>&1; then
    log "Syncing skills for active agent..."
    (cd "$project_root" && aoc-skill sync --active --root "$project_root" || true)
    log "Syncing skills for existing agent targets..."
    (cd "$project_root" && aoc-skill sync --existing --root "$project_root" || true)
  fi
}

# 1c. Setup OpenCode Agents (.opencode/agents)
setup_agents() {
  local opencode_agents_dir="$project_root/.opencode/agents"
  local seed_file=""
  local candidate=""

  for candidate in \
    "$aoc_config_dir/agents/opencode/aoc-ops.md" \
    "$script_dir/../.aoc/agents/opencode/aoc-ops.md"; do
    if [[ -f "$candidate" ]]; then
      seed_file="$candidate"
      break
    fi
  done

  if [[ -z "$seed_file" ]]; then
    warn "No OpenCode agent template found; skipping agent seeding."
    return
  fi

  if [[ ! -d "$opencode_agents_dir" ]]; then
    mkdir -p "$opencode_agents_dir"
  fi

  if [[ ! -f "$opencode_agents_dir/aoc-ops.md" ]]; then
    cp "$seed_file" "$opencode_agents_dir/aoc-ops.md"
    log "Seeded OpenCode agent: aoc-ops"
  else
    log "OpenCode agent already present. Preserving."
  fi
}

# 1d. Setup OpenCode Commands (.opencode/commands)
setup_opencode_commands() {
  local opencode_commands_dir="$project_root/.opencode/commands"
  local candidate=""
  local commands_seed_dirs=(
    "$aoc_config_dir/commands/opencode"
    "$script_dir/../.aoc/commands/opencode"
  )

  if [[ ! -d "$opencode_commands_dir" ]]; then
    mkdir -p "$opencode_commands_dir"
  fi

  local seeded_any=0
  local seed_file=""
  local target_file=""
  for candidate in "${commands_seed_dirs[@]}"; do
    [[ -d "$candidate" ]] || continue
    shopt -s nullglob
    for seed_file in "$candidate"/*.md; do
      target_file="$opencode_commands_dir/$(basename "$seed_file")"
      if [[ ! -f "$target_file" ]]; then
        cp "$seed_file" "$target_file"
        log "Seeded OpenCode command: /$(basename "$seed_file" .md)"
      else
        log "OpenCode command /$(basename "$seed_file" .md) already present. Preserving."
      fi
      seeded_any=1
    done
    shopt -u nullglob
  done

  if [[ "$seeded_any" != "1" ]]; then
    warn "No OpenCode command templates found; skipping command seeding."
  fi
}

# 2. Setup Taskmaster (.taskmaster/)
setup_tasks() {
  log "Initializing Taskmaster..."

  mkdir -p "$task_dir/tasks" "$task_dir/docs/prds" "$task_dir/reports" "$task_dir/templates"

  local native_init_ok=0
  if command -v aoc-task >/dev/null 2>&1; then
    if (cd "$project_root" && aoc-task init >/dev/null 2>&1); then
      native_init_ok=1
    else
      warn "aoc-task init failed; using shell fallback for task scaffolding."
    fi
  elif command -v aoc-cli >/dev/null 2>&1; then
    if (cd "$project_root" && aoc-cli task init >/dev/null 2>&1); then
      native_init_ok=1
    else
      warn "aoc-cli task init failed; using shell fallback for task scaffolding."
    fi
  fi

  if [[ "$native_init_ok" != "1" ]]; then
    if [[ ! -f "$task_dir/tasks/tasks.json" ]]; then
      cat <<EOF > "$task_dir/tasks/tasks.json"
{
  "master": {
    "tasks": []
  }
}
EOF
    fi

    if [[ ! -f "$task_dir/state.json" ]]; then
      now_stamp="$(date -u +%Y-%m-%dT%H:%M:%S.%3NZ)"
      cat <<EOF > "$task_dir/state.json"
{
  "currentTag": "master",
  "lastUpdated": "${now_stamp}",
  "lastSwitched": "${now_stamp}",
  "branchTagMapping": {},
  "migrationNoticeShown": true
}
EOF
    fi
  fi

  local template_name=""
  local template_src=""
  local candidate=""
  local template_candidates=(
    "$aoc_config_dir/taskmaster/templates"
    "$script_dir/../.taskmaster/templates"
  )

  for template_name in "example_prd.txt" "example_prd_rpg.txt"; do
    if [[ -f "$task_dir/templates/$template_name" ]]; then
      continue
    fi
    template_src=""
    for candidate in "${template_candidates[@]}"; do
      if [[ -f "$candidate/$template_name" ]]; then
        template_src="$candidate/$template_name"
        break
      fi
    done
    if [[ -n "$template_src" ]]; then
      cp "$template_src" "$task_dir/templates/$template_name"
      log "Seeded Taskmaster template: $task_dir/templates/$template_name"
    else
      warn "No upstream template found for $template_name."
    fi
  done

  local project_prd="$task_dir/docs/prd.md"
  if [[ ! -f "$project_prd" ]]; then
    if [[ -f "$task_dir/templates/example_prd.txt" ]]; then
      cp "$task_dir/templates/example_prd.txt" "$project_prd"
      log "Seeded project PRD from upstream template: $project_prd"
    else
      cat <<'EOF' > "$project_prd"
# Product Requirements Document

## Problem
Describe the core user problem this project solves.

## Goals
-

## Non-Goals
-

## User Stories
- As a <user>, I want <capability> so that <outcome>.

## Requirements
-

## Acceptance Criteria
- [ ]

## Constraints
-

## Risks
-

## Test Strategy
-
EOF
      log "Seeded fallback project PRD template: $project_prd"
    fi
  fi

  local project_prd_txt="$task_dir/docs/prd.txt"
  if [[ -f "$project_prd" && ! -f "$project_prd_txt" ]]; then
    cp "$project_prd" "$project_prd_txt"
    log "Seeded Taskmaster-compatible project PRD copy: $project_prd_txt"
  fi

  # Config Seeding (Preserve existing logic, but ensure Gemini preference)
  local local_conf="$task_dir/config.json"
  
  if [[ -f "$global_task_conf" ]]; then
    if [[ ! -f "$local_conf" ]]; then
      log "Seeding Taskmaster config from global defaults..."
      cp "$global_task_conf" "$local_conf"
    else
      # Advanced: We could merge JSON here, but for now we trust the local config
      # if it exists, assuming the user might have customized it for this specific repo.
      log "Local Taskmaster config exists. Preserving."
    fi
  else
    warn "No global Taskmaster config found at $global_task_conf. Skipping seed."
  fi
}

# 3. Environment Checks
setup_env() {
  if [[ ! -f "$project_root/.env" && -f "$project_root/.env.example" ]]; then
    log "Copying .env.example to .env..."
    cp "$project_root/.env.example" "$project_root/.env"
  fi
}

# 4. Ensure AOC Rust binaries are available
setup_binaries() {
  if [[ "${AOC_INIT_SKIP_BUILD:-0}" == "1" ]]; then
    log "Skipping Rust binary build (AOC_INIT_SKIP_BUILD=1)."
    return
  fi

  local manifest_path=""
  if [[ -f "$project_root/crates/Cargo.toml" ]]; then
    manifest_path="$project_root/crates/Cargo.toml"
  elif [[ -f "$script_dir/../crates/Cargo.toml" ]]; then
    manifest_path="$script_dir/../crates/Cargo.toml"
  fi

  local required=(aoc-hub-rs aoc-agent-wrap-rs aoc-mission-control aoc-taskmaster aoc-control)
  local missing=()
  local bin=""
  local manifest_dir=""
  if [[ -n "$manifest_path" ]]; then
    manifest_dir="$(dirname "$manifest_path")"
  fi

  for bin in "${required[@]}"; do
    if command -v "$bin" >/dev/null 2>&1; then
      continue
    fi
    if [[ -n "$manifest_dir" ]]; then
      if [[ -x "$manifest_dir/target/release/$bin" || -x "$manifest_dir/target/debug/$bin" ]]; then
        continue
      fi
    fi
    missing+=("$bin")
  done

  if ((${#missing[@]} == 0)); then
    log "Rust binaries already available. Skipping build."
    return
  fi

  if [[ -z "$manifest_path" ]]; then
    warn "Rust workspace not found. Missing binaries: ${missing[*]}"
    return
  fi

  if ! command -v cargo >/dev/null 2>&1; then
    warn "cargo not found; unable to build binaries: ${missing[*]}"
    return
  fi

  log "Building AOC Rust binaries: ${required[*]}"
  cargo build --manifest-path "$manifest_path" -p aoc-hub-rs -p aoc-agent-wrap-rs -p aoc-mission-control -p aoc-taskmaster -p aoc-control
}

main() {
  log "Initializing AOC in: $project_root"
  setup_memory
  setup_skills
  setup_agents
  setup_opencode_commands
  setup_tasks
  setup_env
  setup_binaries
  log "AOC Initialization Complete. Ready to launch."
}

main
