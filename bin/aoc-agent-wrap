#!/usr/bin/env bash
set -euo pipefail

agent_id="${1:-}"
agent_bin="${2:-}"
agent_label="${3:-}"
shift 3 || true

# Set title early, before any execs
if [[ -n "$agent_label" ]]; then
  printf "\033]0;Agent [$agent_label]\007"
fi

if [[ -z "$agent_id" || -z "$agent_bin" ]]; then
  echo "Usage: aoc-agent-wrap <id> <bin> [label] [args...]" >&2
  exit 1
fi

if [[ -z "$agent_label" ]]; then
  agent_label="$agent_id"
fi

env_hint="AOC_${agent_id^^}_BIN"

# --- Resolution Logic ---

script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
home_bin="${HOME}/bin"
cargo_bin="$HOME/.cargo/bin"

resolve_session_id() {
  if [[ -n "${ZELLIJ_SESSION_NAME:-}" ]]; then
    printf '%s' "$ZELLIJ_SESSION_NAME"
    return
  fi
  if [[ -n "${AOC_SESSION_ID:-}" ]]; then
    printf '%s' "$AOC_SESSION_ID"
    return
  fi
  printf 'pid-%s' "$$"
}

resolve_pane_id() {
  if [[ -n "${AOC_PANE_ID:-}" ]]; then
    printf '%s' "$AOC_PANE_ID"
    return
  fi
  if [[ -n "${ZELLIJ_PANE_ID:-}" ]]; then
    printf '%s' "$ZELLIJ_PANE_ID"
    return
  fi
  printf '%s' "$$"
}

resolve_project_root() {
  if [[ -n "${AOC_PROJECT_ROOT:-}" ]]; then
    printf '%s' "$AOC_PROJECT_ROOT"
    return
  fi
  printf '%s' "$PWD"
}

derive_port() {
  local session="$1"
  if ! command -v python3 >/dev/null 2>&1; then
    printf '42000'
    return
  fi
  python3 - <<'PY' "$session"
import sys
session = sys.argv[1].encode()
hash_value = 2166136261
for byte in session:
    hash_value ^= byte
    hash_value = (hash_value * 16777619) & 0xFFFFFFFF
port = 42000 + (hash_value % 2000)
print(port)
PY
}

resolve_hub_addr() {
  local session_id="$1"
  if [[ -n "${AOC_HUB_ADDR:-}" ]]; then
    printf '%s' "$AOC_HUB_ADDR"
    return
  fi
  local port
  port="$(derive_port "$session_id")"
  printf '127.0.0.1:%s' "$port"
}

resolve_hub_url() {
  local hub_addr="$1"
  if [[ -n "${AOC_HUB_URL:-}" ]]; then
    printf '%s' "$AOC_HUB_URL"
    return
  fi
  printf 'ws://%s/ws' "$hub_addr"
}

wrap_rs_cmd=()
resolve_wrap_rs_cmd() {
  wrap_rs_cmd=()
  if [[ -n "${AOC_AGENT_WRAP_RS_BIN:-}" ]]; then
    wrap_rs_cmd=("$AOC_AGENT_WRAP_RS_BIN")
    return
  fi
  local local_release="$script_dir/../crates/target/release/aoc-agent-wrap-rs"
  local local_debug="$script_dir/../crates/target/debug/aoc-agent-wrap-rs"
  if [[ -x "$local_release" ]]; then
    wrap_rs_cmd=("$local_release")
    return
  fi
  if [[ -x "$local_debug" ]]; then
    wrap_rs_cmd=("$local_debug")
    return
  fi
  if command -v aoc-agent-wrap-rs >/dev/null 2>&1; then
    wrap_rs_cmd=(aoc-agent-wrap-rs)
    return
  fi
  if [[ -x "$home_bin/aoc-agent-wrap-rs" ]]; then
    wrap_rs_cmd=("$home_bin/aoc-agent-wrap-rs")
    return
  fi
  if [[ -x "$cargo_bin/aoc-agent-wrap-rs" ]]; then
    wrap_rs_cmd=("$cargo_bin/aoc-agent-wrap-rs")
    return
  fi
  local manifest_path=""
  if [[ -n "${AOC_PROJECT_ROOT:-}" && -f "${AOC_PROJECT_ROOT}/crates/Cargo.toml" ]]; then
    manifest_path="${AOC_PROJECT_ROOT}/crates/Cargo.toml"
  elif [[ -f "$script_dir/../crates/Cargo.toml" ]]; then
    manifest_path="$script_dir/../crates/Cargo.toml"
  fi
  if command -v cargo >/dev/null 2>&1 && [[ -n "$manifest_path" ]]; then
    wrap_rs_cmd=(cargo run --manifest-path "$manifest_path" -p aoc-agent-wrap-rs --)
  fi
}

is_wrapper() {
  local candidate="$1"
  local head=""
  if [[ ! -f "$candidate" ]]; then
    return 1
  fi
  head="$(head -n 1 "$candidate" 2>/dev/null || true)"
  if [[ "$head" == "#!/usr/bin/env bash" ]]; then
    # Heuristic: if it mentions "aoc-" or "tmux -L aoc-" it's likely a wrapper
    if grep -E -q "aoc-|tmux -L aoc-" "$candidate" 2>/dev/null; then
      return 0
    fi
  fi
  return 1
}

resolve_bin() {
  local name="$1"
  local env_var="$2"
  
  # Check environment variable first
  local env_val=""
  env_val="$(printenv "$env_var" || true)"
  if [[ -n "$env_val" ]]; then
    echo "$env_val"
    return
  fi

  # Search full PATH
  local part=""
  local candidate=""
  IFS=':' read -r -a parts <<<"$PATH"
  for part in "${parts[@]}"; do
    [[ -n "$part" ]] || continue
    candidate="$part/$name"
    if [[ -x "$candidate" ]]; then
      if is_wrapper "$candidate"; then
        continue
      fi
      echo "$candidate"
      return
    fi
  done

  if [[ "$name" == "opencode" || "$name" == "open-code" ]]; then
    local pnpm_home="${PNPM_HOME:-$HOME/.local/share/pnpm}"
    local pinned_version="${AOC_OC_VERSION:-}"
    local candidates=()
    local base=""
    for base in "$pnpm_home"/global/*/.pnpm; do
      [[ -d "$base" ]] || continue
      if [[ -n "$pinned_version" ]]; then
        for candidate in "$base"/opencode-ai@"$pinned_version"/node_modules/opencode-ai/bin/opencode; do
          [[ -x "$candidate" ]] || continue
          echo "$candidate"
          return
        done
        for candidate in "$base"/opencode@"$pinned_version"/node_modules/opencode/bin/opencode; do
          [[ -x "$candidate" ]] || continue
          echo "$candidate"
          return
        done
      fi
      for candidate in "$base"/opencode-ai@*/node_modules/opencode-ai/bin/opencode; do
        [[ -x "$candidate" ]] || continue
        candidates+=("$candidate")
      done
      for candidate in "$base"/opencode@*/node_modules/opencode/bin/opencode; do
        [[ -x "$candidate" ]] || continue
        candidates+=("$candidate")
      done
    done
    if ((${#candidates[@]} > 0)); then
      printf '%s\n' "${candidates[@]}" | sort -V | tail -n 1
      return
    fi
  fi
  
  echo "$name"
}

real_bin="$(resolve_bin "$agent_bin" "$env_hint")"

resolved_path="$(command -v "$real_bin" 2>/dev/null || true)"
if [[ -n "$resolved_path" ]] && is_wrapper "$resolved_path"; then
  clear
  echo "$agent_label CLI resolves to an AOC wrapper ($resolved_path)."
  echo "Install the real binary and set $env_hint to its path."
  echo
  read -rsn1 -p "Press any key to exit." _ || true
  exit 0
fi

if ! command -v "$real_bin" >/dev/null 2>&1; then
  clear
  echo "$agent_label CLI ('$agent_bin') not found in PATH."
  echo "Set $env_hint to override the binary."
  echo
  read -rsn1 -p "Press any key to exit." _ || true
  exit 0
fi

session_id="$(resolve_session_id)"
pane_id="$(resolve_pane_id)"
project_root="$(resolve_project_root)"
hub_addr="$(resolve_hub_addr "$session_id")"
hub_url="$(resolve_hub_url "$hub_addr")"

export AOC_SESSION_ID="$session_id"
export AOC_PANE_ID="$pane_id"
export AOC_PROJECT_ROOT="$project_root"
export AOC_HUB_ADDR="$hub_addr"
export AOC_HUB_URL="$hub_url"
export AOC_AGENT_LABEL="$agent_label"
if [[ -z "${AOC_TAB_SCOPE:-}" ]]; then
  if [[ -n "${AOC_TAB_NAME:-}" ]]; then
    export AOC_TAB_SCOPE="$AOC_TAB_NAME"
  elif [[ -n "${ZELLIJ_TAB_NAME:-}" ]]; then
    export AOC_TAB_SCOPE="$ZELLIJ_TAB_NAME"
  fi
fi
if [[ -z "${AOC_AGENT_PTY:-}" ]]; then
  export AOC_AGENT_PTY=0
fi
if [[ -z "${AOC_AGENT_ID:-}" ]]; then
  export AOC_AGENT_ID="$agent_id"
fi

sanitize_component() {
  local input="$1"
  local output
  output="$(printf '%s' "$input" | sed -E 's/[^A-Za-z0-9._-]+/_/g')"
  printf '%s' "${output:-unknown}"
}

state_dir="${XDG_STATE_HOME:-$HOME/.local/state}/aoc"
lease_session="$(sanitize_component "${AOC_SESSION_ID:-unknown}")"
lease_pane="$(sanitize_component "${AOC_PANE_ID:-${ZELLIJ_PANE_ID:-unknown}}")"
lease_dir="$state_dir/pane-leases/$lease_session"
lease_file="$lease_dir/${lease_pane}.lease"
instance_seed="$(date +%s 2>/dev/null || printf '%s' "$$")"
pane_instance_id="${AOC_PANE_INSTANCE_ID:-${AOC_SESSION_ID:-pid}-${AOC_PANE_ID:-${ZELLIJ_PANE_ID:-$$}}-$$-${RANDOM}-${instance_seed}}"
mkdir -p "$lease_dir" 2>/dev/null || true
printf '%s\n' "$pane_instance_id" >"$lease_file" 2>/dev/null || true
export AOC_PANE_INSTANCE_ID="$pane_instance_id"
export AOC_PANE_LEASE_FILE="$lease_file"

# --- Context Injection (Handshake) ---

find_aoc_dir() {
  local base=""
  local probe=""
  if [[ -n "${AOC_PROJECT_ROOT:-}" && -d "${AOC_PROJECT_ROOT}/.aoc" ]]; then
    echo "${AOC_PROJECT_ROOT}/.aoc"
    return 0
  fi
  base="$PWD"
  # Prefer aoc-align only when it matches the current pane's path.
  if command -v aoc-align >/dev/null 2>&1; then
    local aligned=""
    aligned="$(aoc-align --print-root 2>/dev/null || true)"
    if [[ -n "$aligned" ]]; then
      case "$base" in
        "$aligned"|"$aligned"/*) base="$aligned" ;;
      esac
    fi
  fi

  probe="$base"
  while [[ -n "$probe" && "$probe" != "/" ]]; do
    if [[ -d "$probe/.aoc" ]]; then
      echo "$probe/.aoc"
      return 0
    fi
    probe="$(dirname "$probe")"
  done

  if [[ -d "$script_dir/../.aoc" ]]; then
    echo "$script_dir/../.aoc"
    return 0
  fi

  if [[ -d "$base/.gemini" ]]; then
    echo "$base/.gemini"
    return 0
  fi

  return 1
}

construct_handshake() {
  local aoc_dir=""
  local stm_file=""
  if ! aoc_dir="$(find_aoc_dir)"; then
    return
  fi

  if [[ -n "${AOC_STM_INJECT_FILE:-}" ]]; then
    stm_file="$AOC_STM_INJECT_FILE"
    if [[ -f "$aoc_dir/stm/next.path" ]]; then
      local queued_stm=""
      queued_stm="$(head -n 1 "$aoc_dir/stm/next.path" 2>/dev/null || true)"
      if [[ "$queued_stm" == "$stm_file" ]]; then
        rm -f "$aoc_dir/stm/next.path"
      fi
    fi
  elif [[ -f "$aoc_dir/stm/next.path" ]]; then
    stm_file="$(head -n 1 "$aoc_dir/stm/next.path" 2>/dev/null || true)"
    rm -f "$aoc_dir/stm/next.path"
  fi

  echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
  echo "ðŸš€ AOC SYSTEM HANDSHAKE (Agent Orientation)"
  echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
  echo
  echo "You are running in an Agent Ops Cockpit (AOC) managed environment."
  echo "This terminal history contains your initial project orientation."
  echo
  echo "ðŸ“‚ PROJECT CONTEXT ($aoc_dir/context.md):"
  if [[ -f "$aoc_dir/context.md" ]]; then
    head -n 50 "$aoc_dir/context.md"
    echo "... [see file for full content]"
  elif [[ -f "$aoc_dir/GEMINI.md" ]]; then
    head -n 50 "$aoc_dir/GEMINI.md"
  fi
  echo
  echo "ðŸ§  PROJECT MEMORY ($aoc_dir/memory.md):"
  if [[ -f "$aoc_dir/memory.md" ]]; then
    tail -n 20 "$aoc_dir/memory.md"
  fi
  echo
  echo "ðŸ“‹ ACTIVE TASKS (.taskmaster/):"
  if command -v aoc-task >/dev/null 2>&1; then
    aoc-task list --tag "${AOC_TAG:-master}" 2>/dev/null | head -n 20 || echo "No active tasks."
  elif command -v aoc-cli >/dev/null 2>&1; then
    aoc-cli task list --tag "${AOC_TAG:-master}" 2>/dev/null | head -n 20 || echo "No active tasks."
  elif command -v task-master >/dev/null 2>&1; then
    task-master list --tag "${AOC_TAG:-master}" 2>/dev/null | head -n 20 || echo "No active tasks."
  fi

  if [[ -n "$stm_file" && -f "$stm_file" ]]; then
    echo
    echo "âš¡ SHORT-TERM MEMORY HANDOFF ($stm_file):"
    head -n 120 "$stm_file"
    echo "... [end of STM handoff]"
    if [[ -n "${AOC_STM_ACTIVE_FILE:-}" ]]; then
      : > "$AOC_STM_ACTIVE_FILE" 2>/dev/null || true
    fi
  fi

  echo
  echo "ðŸ’¡ OPERATIONAL DIRECTIVE:"
  echo "1. The file '$aoc_dir/memory.md' is the LIVE source of truth for architectural decisions."
  echo "2. Use 'aoc-mem add \"fact\"' to record new decisions."
  echo "3. Use 'aoc-task' (or 'task-master') tools to track your progress."
  echo "4. If a task has a PRD link, read it before implementation (aoc-task prd show <task-id>)."
  echo "5. PRD links are task-level only; subtasks must not define PRD links."
  echo "6. Track ephemeral session state with aoc-stm add/edit; use aoc-stm to hand off when context gets tight."
  echo
  echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
  echo "Starting ${AOC_AGENT_LABEL:-$agent_label} CLI..."
  echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
}

# We'll use a temporary script to handle the handshake and exec to avoid complex quoting in tmux
bootloader="$(mktemp /tmp/aoc-bootloader-XXXXXX.sh)"
chmod +x "$bootloader"
{
  echo "#!/usr/bin/env bash"
  declare -f find_aoc_dir
  echo "construct_handshake() {"
  declare -f construct_handshake | tail -n +2
  echo "}"
  echo "printf \"\\033]0;Agent [$agent_label]\\007\""
  echo "construct_handshake"
  echo "rm -f \"\$0\"" # Self-destruct
  echo "exec \"$real_bin\" \"\$@\""
} > "$bootloader"

resolve_wrap_rs_cmd
wrapped_cmd=()
if ((${#wrap_rs_cmd[@]} > 0)); then
  wrap_rs_help=""
  wrap_rs_supports_hub_addr=0
  wrap_rs_supports_tab_scope=0
  if [[ -n "${AOC_TAB_SCOPE:-}" || -n "${AOC_HUB_ADDR:-}" ]]; then
    wrap_rs_help="$("${wrap_rs_cmd[@]}" --help 2>/dev/null || true)"
    if [[ "$wrap_rs_help" == *"--hub-addr"* ]]; then
      wrap_rs_supports_hub_addr=1
    fi
    if [[ "$wrap_rs_help" == *"--tab-scope"* ]]; then
      wrap_rs_supports_tab_scope=1
    fi
  fi
  wrapped_cmd=(
    "${wrap_rs_cmd[@]}"
    --session "$AOC_SESSION_ID"
    --pane-id "$AOC_PANE_ID"
    --agent-id "$AOC_AGENT_LABEL"
    --project-root "$AOC_PROJECT_ROOT"
  )
  if [[ "$wrap_rs_supports_tab_scope" == "1" && -n "${AOC_TAB_SCOPE:-}" ]]; then
    wrapped_cmd+=(--tab-scope "${AOC_TAB_SCOPE:-}")
  fi
  if [[ "$wrap_rs_supports_hub_addr" == "1" ]]; then
    wrapped_cmd+=(--hub-addr "$AOC_HUB_ADDR")
  fi
  wrapped_cmd+=(
    --
    "$bootloader"
    "$@"
  )
else
  wrapped_cmd=("$bootloader" "$@")
fi

pane_cleanup=0
if [[ -n "${AOC_PANE_ID:-}" || -n "${ZELLIJ_PANE_ID:-}" ]]; then
  pane_cleanup=1
fi

reap_conflicting_pane_processes() {
  if [[ "$pane_cleanup" != "1" ]]; then
    return
  fi
  local pane_id="${AOC_PANE_ID:-${ZELLIJ_PANE_ID:-}}"
  local session_id="${ZELLIJ_SESSION_NAME:-${AOC_SESSION_ID:-}}"
  local project_root="${AOC_PROJECT_ROOT:-}"
  if [[ -z "$pane_id" || -z "$session_id" ]]; then
    return
  fi

  python3 - "$pane_id" "$session_id" "$project_root" "${BASHPID:-$$}" <<'PY'
import os
import signal
import subprocess
import sys
import time

pane_id = sys.argv[1] if len(sys.argv) > 1 else ""
session_id = sys.argv[2] if len(sys.argv) > 2 else ""
project_root = sys.argv[3] if len(sys.argv) > 3 else ""
self_pid = int(sys.argv[4]) if len(sys.argv) > 4 and sys.argv[4].isdigit() else 0

if not pane_id or not session_id:
    raise SystemExit(0)

def proc_env(pid):
    try:
        with open(f"/proc/{pid}/environ", "rb") as fh:
            data = fh.read().split(b"\0")
    except Exception:
        return {}
    env = {}
    for item in data:
        if not item or b"=" not in item:
            continue
        key, value = item.split(b"=", 1)
        env[key.decode("utf-8", "ignore")] = value.decode("utf-8", "ignore")
    return env

try:
    ps_out = subprocess.check_output(["ps", "-eo", "pid,args"], text=True)
except Exception:
    raise SystemExit(0)

targets = []
for line in ps_out.strip().splitlines()[1:]:
    parts = line.strip().split(None, 1)
    if len(parts) != 2:
        continue
    try:
        pid = int(parts[0])
    except ValueError:
        continue
    if pid <= 0 or pid == self_pid:
        continue
    args = parts[1]
    if "aoc-agent-wrap" not in args and "opencode" not in args and "codex" not in args and "gemini" not in args and "claude" not in args and "kimi" not in args:
        continue
    env = proc_env(pid)
    proc_pane = env.get("AOC_PANE_ID") or env.get("ZELLIJ_PANE_ID") or ""
    if proc_pane != pane_id:
        continue
    proc_session = env.get("ZELLIJ_SESSION_NAME") or env.get("AOC_SESSION_ID") or ""
    if proc_session != session_id:
        continue
    if project_root:
        proc_root = env.get("AOC_PROJECT_ROOT") or ""
        if proc_root == project_root:
            # same pane/session/root implies duplicate stale instance
            pass
    targets.append(pid)

if not targets:
    raise SystemExit(0)

targets = sorted(set(targets), reverse=True)
for pid in targets:
    try:
        os.kill(pid, signal.SIGTERM)
    except ProcessLookupError:
        pass

time.sleep(0.3)

for pid in targets:
    try:
        os.kill(pid, signal.SIGKILL)
    except ProcessLookupError:
        pass
PY
}

reap_conflicting_pane_processes

cleanup_done=0
kill_pane_agents_by_env() {
  if [[ "$pane_cleanup" != "1" ]]; then
    return
  fi
  local pane_id="${AOC_PANE_ID:-${ZELLIJ_PANE_ID:-}}"
  local session_id="${ZELLIJ_SESSION_NAME:-${AOC_SESSION_ID:-}}"
  local instance_id="${AOC_PANE_INSTANCE_ID:-}"
  if [[ -z "$pane_id" ]]; then
    return
  fi

  python3 - "$pane_id" "$session_id" "${BASHPID:-$$}" "$instance_id" <<'PY'
import os
import signal
import subprocess
import sys
import time

pane_id = sys.argv[1] if len(sys.argv) > 1 else ""
session_id = sys.argv[2] if len(sys.argv) > 2 else ""
skip_pid = 0
instance_id = sys.argv[4] if len(sys.argv) > 4 else ""
if len(sys.argv) > 3:
    try:
        skip_pid = int(sys.argv[3])
    except ValueError:
        skip_pid = 0
if not pane_id:
    raise SystemExit(0)

self_pid = os.getpid()

def proc_env(pid):
    try:
        with open(f"/proc/{pid}/environ", "rb") as fh:
            data = fh.read().split(b"\0")
    except Exception:
        return {}
    env = {}
    for item in data:
        if not item or b"=" not in item:
            continue
        key, value = item.split(b"=", 1)
        try:
            k = key.decode("utf-8", errors="ignore")
            v = value.decode("utf-8", errors="ignore")
        except Exception:
            continue
        if k:
            env[k] = v
    return env

try:
    ps_out = subprocess.check_output(["ps", "-eo", "pid,comm,args"], text=True)
except Exception:
    raise SystemExit(0)

pids = []
for line in ps_out.strip().splitlines()[1:]:
    parts = line.strip().split(None, 2)
    if not parts:
        continue
    try:
        pid = int(parts[0])
    except ValueError:
        continue
    if pid == self_pid or (skip_pid and pid == skip_pid):
        continue
    env = proc_env(pid)
    if instance_id:
        if env.get("AOC_PANE_INSTANCE_ID") != instance_id:
            continue
    else:
        same_pane = env.get("AOC_PANE_ID") == pane_id or env.get("ZELLIJ_PANE_ID") == pane_id
        if not same_pane:
            continue
        if session_id:
            proc_session = env.get("ZELLIJ_SESSION_NAME") or env.get("AOC_SESSION_ID") or ""
            if proc_session and proc_session != session_id:
                continue
    pids.append(pid)

pids = sorted(set(pids), reverse=True)

for pid in pids:
    try:
        os.kill(pid, signal.SIGTERM)
    except ProcessLookupError:
        pass

time.sleep(0.4)

for pid in pids:
    try:
        os.kill(pid, signal.SIGKILL)
    except ProcessLookupError:
        pass
PY
}

cleanup_pane_agents() {
  if [[ "$cleanup_done" == "1" ]]; then
    return
  fi
  cleanup_done=1
  kill_pane_agents_by_env
  if [[ -n "${AOC_PANE_LEASE_FILE:-}" && -n "${AOC_PANE_INSTANCE_ID:-}" ]]; then
    if [[ -f "$AOC_PANE_LEASE_FILE" ]]; then
      lease_owner="$(head -n 1 "$AOC_PANE_LEASE_FILE" 2>/dev/null || true)"
      if [[ "$lease_owner" == "$AOC_PANE_INSTANCE_ID" ]]; then
        rm -f "$AOC_PANE_LEASE_FILE" 2>/dev/null || true
      fi
    fi
  fi
}

start_orphan_watchdog() {
  if [[ "$pane_cleanup" != "1" ]]; then
    return
  fi
  local pane_id="${AOC_PANE_ID:-${ZELLIJ_PANE_ID:-}}"
  local session_id="${ZELLIJ_SESSION_NAME:-${AOC_SESSION_ID:-}}"
  local instance_id="${AOC_PANE_INSTANCE_ID:-}"
  local lease_file="${AOC_PANE_LEASE_FILE:-}"
  if [[ -z "$pane_id" ]]; then
    return
  fi
  if ! command -v python3 >/dev/null 2>&1; then
    return
  fi

  local parent_pid="$$"
  local watcher_cmd=(python3 - "$parent_pid" "$pane_id" "$session_id" "$instance_id" "$lease_file")

  if command -v setsid >/dev/null 2>&1; then
    setsid "${watcher_cmd[@]}" >/dev/null 2>&1 <<'PY' &
import os
import re
import signal
import subprocess
import sys
import time

parent_pid = int(sys.argv[1])
pane_id = sys.argv[2]
session_id = sys.argv[3] if len(sys.argv) > 3 else ""
instance_id = sys.argv[4] if len(sys.argv) > 4 else ""
lease_file = sys.argv[5] if len(sys.argv) > 5 else ""

if not pane_id:
    raise SystemExit(0)

self_pid = os.getpid()

def parse_int(name, default, minimum=1, maximum=60):
    raw = os.environ.get(name, "").strip()
    if not raw:
        return default
    try:
        value = int(raw)
    except ValueError:
        return default
    if value < minimum:
        return minimum
    if value > maximum:
        return maximum
    return value

def parse_float(name, default, minimum=0.2, maximum=60.0):
    raw = os.environ.get(name, "").strip()
    if not raw:
        return default
    try:
        value = float(raw)
    except ValueError:
        return default
    if value < minimum:
        return minimum
    if value > maximum:
        return maximum
    return value

pane_miss_limit = parse_int("AOC_ORPHAN_PANE_MISS_MAX", 4, minimum=1, maximum=60)
loop_sleep_secs = parse_float("AOC_ORPHAN_PANE_POLL_SECS", 3.0)

def pid_alive(pid):
    try:
        os.kill(pid, 0)
        return True
    except ProcessLookupError:
        return False
    except PermissionError:
        return True

def proc_env(pid):
    try:
        with open(f"/proc/{pid}/environ", "rb") as fh:
            data = fh.read().split(b"\0")
    except Exception:
        return {}
    env = {}
    for item in data:
        if not item or b"=" not in item:
            continue
        key, value = item.split(b"=", 1)
        env[key.decode("utf-8", "ignore")] = value.decode("utf-8", "ignore")
    return env

def lease_owned():
    if not instance_id or not lease_file:
        return True
    try:
        with open(lease_file, "r", encoding="utf-8") as fh:
            owner = fh.readline().strip()
    except Exception:
        return False
    return owner == instance_id

def matching_pids():
    try:
        ps_out = subprocess.check_output(["ps", "-eo", "pid,comm,args"], text=True)
    except Exception:
        return []
    found = []
    for line in ps_out.strip().splitlines()[1:]:
        parts = line.strip().split(None, 2)
        if not parts:
            continue
        try:
            pid = int(parts[0])
        except ValueError:
            continue
        if pid == self_pid:
            continue
        env = proc_env(pid)
        if instance_id:
            if env.get("AOC_PANE_INSTANCE_ID") != instance_id:
                continue
        else:
            same_pane = env.get("AOC_PANE_ID") == pane_id or env.get("ZELLIJ_PANE_ID") == pane_id
            if not same_pane:
                continue
            if session_id:
                proc_session = env.get("ZELLIJ_SESSION_NAME") or env.get("AOC_SESSION_ID") or ""
                if proc_session and proc_session != session_id:
                    continue
        found.append(pid)
    return sorted(set(found), reverse=True)

def session_pane_missing():
    if not session_id:
        return False
    try:
        sessions_raw = subprocess.check_output(
            ["zellij", "list-sessions", "--short", "--no-formatting"],
            text=True,
            timeout=2,
        )
        sessions = {line.strip() for line in sessions_raw.splitlines() if line.strip()}
        if sessions and session_id not in sessions:
            return True
    except Exception:
        pass
    return False

pane_misses = 0
while True:
    if not pid_alive(parent_pid):
        break
    if not lease_owned():
        break
    if session_pane_missing():
        pane_misses += 1
        if pane_misses >= pane_miss_limit:
            break
    else:
        pane_misses = 0
    time.sleep(loop_sleep_secs)

pids = matching_pids()
for pid in pids:
    try:
        os.kill(pid, signal.SIGTERM)
    except ProcessLookupError:
        pass

time.sleep(0.4)

for pid in pids:
    try:
        os.kill(pid, signal.SIGKILL)
    except ProcessLookupError:
        pass
PY
  else
    nohup "${watcher_cmd[@]}" >/dev/null 2>&1 <<'PY' &
import os
import re
import signal
import subprocess
import sys
import time

parent_pid = int(sys.argv[1])
pane_id = sys.argv[2]
session_id = sys.argv[3] if len(sys.argv) > 3 else ""
instance_id = sys.argv[4] if len(sys.argv) > 4 else ""
lease_file = sys.argv[5] if len(sys.argv) > 5 else ""

if not pane_id:
    raise SystemExit(0)

self_pid = os.getpid()

def parse_int(name, default, minimum=1, maximum=60):
    raw = os.environ.get(name, "").strip()
    if not raw:
        return default
    try:
        value = int(raw)
    except ValueError:
        return default
    if value < minimum:
        return minimum
    if value > maximum:
        return maximum
    return value

def parse_float(name, default, minimum=0.2, maximum=60.0):
    raw = os.environ.get(name, "").strip()
    if not raw:
        return default
    try:
        value = float(raw)
    except ValueError:
        return default
    if value < minimum:
        return minimum
    if value > maximum:
        return maximum
    return value

pane_miss_limit = parse_int("AOC_ORPHAN_PANE_MISS_MAX", 4, minimum=1, maximum=60)
loop_sleep_secs = parse_float("AOC_ORPHAN_PANE_POLL_SECS", 3.0)

def pid_alive(pid):
    try:
        os.kill(pid, 0)
        return True
    except ProcessLookupError:
        return False
    except PermissionError:
        return True

def proc_env(pid):
    try:
        with open(f"/proc/{pid}/environ", "rb") as fh:
            data = fh.read().split(b"\0")
    except Exception:
        return {}
    env = {}
    for item in data:
        if not item or b"=" not in item:
            continue
        key, value = item.split(b"=", 1)
        env[key.decode("utf-8", "ignore")] = value.decode("utf-8", "ignore")
    return env

def lease_owned():
    if not instance_id or not lease_file:
        return True
    try:
        with open(lease_file, "r", encoding="utf-8") as fh:
            owner = fh.readline().strip()
    except Exception:
        return False
    return owner == instance_id

def matching_pids():
    try:
        ps_out = subprocess.check_output(["ps", "-eo", "pid,comm,args"], text=True)
    except Exception:
        return []
    found = []
    for line in ps_out.strip().splitlines()[1:]:
        parts = line.strip().split(None, 2)
        if not parts:
            continue
        try:
            pid = int(parts[0])
        except ValueError:
            continue
        if pid == self_pid:
            continue
        env = proc_env(pid)
        if instance_id:
            if env.get("AOC_PANE_INSTANCE_ID") != instance_id:
                continue
        else:
            same_pane = env.get("AOC_PANE_ID") == pane_id or env.get("ZELLIJ_PANE_ID") == pane_id
            if not same_pane:
                continue
            if session_id:
                proc_session = env.get("ZELLIJ_SESSION_NAME") or env.get("AOC_SESSION_ID") or ""
                if proc_session and proc_session != session_id:
                    continue
        found.append(pid)
    return sorted(set(found), reverse=True)

def session_pane_missing():
    if not session_id:
        return False
    try:
        sessions_raw = subprocess.check_output(
            ["zellij", "list-sessions", "--short", "--no-formatting"],
            text=True,
            timeout=2,
        )
        sessions = {line.strip() for line in sessions_raw.splitlines() if line.strip()}
        if sessions and session_id not in sessions:
            return True
    except Exception:
        pass
    return False

pane_misses = 0
while True:
    if not pid_alive(parent_pid):
        break
    if not lease_owned():
        break
    if session_pane_missing():
        pane_misses += 1
        if pane_misses >= pane_miss_limit:
            break
    else:
        pane_misses = 0
    time.sleep(loop_sleep_secs)

pids = matching_pids()
for pid in pids:
    try:
        os.kill(pid, signal.SIGTERM)
    except ProcessLookupError:
        pass

time.sleep(0.4)

for pid in pids:
    try:
        os.kill(pid, signal.SIGKILL)
    except ProcessLookupError:
        pass
PY
  fi
}

handle_cleanup_signal() {
  cleanup_pane_agents
  exit 0
}

run_with_cleanup() {
  if [[ "$pane_cleanup" != "1" ]]; then
    "$@"
    return $?
  fi
  start_orphan_watchdog
  trap handle_cleanup_signal HUP INT TERM
  trap cleanup_pane_agents EXIT
  set +e
  "$@"
  local status=$?
  set -e
  cleanup_pane_agents
  trap - HUP INT TERM EXIT
  return "$status"
}

if [[ "$agent_id" != "codex" ]]; then
  if [[ "$pane_cleanup" == "1" ]]; then
    if run_with_cleanup "${wrapped_cmd[@]}"; then
      status=0
    else
      status=$?
    fi
    exit "$status"
  fi
  exec "${wrapped_cmd[@]}"
fi

if [[ "${AOC_NO_TMUX:-0}" == "1" ]]; then
  if [[ "$pane_cleanup" == "1" ]]; then
    if run_with_cleanup "${wrapped_cmd[@]}"; then
      status=0
    else
      status=$?
    fi
    exit "$status"
  fi
  exec "${wrapped_cmd[@]}"
fi

if ! command -v tmux >/dev/null 2>&1; then
  echo "aoc-$agent_id: tmux not found; running $agent_bin with handshake but no tmux wrapper." >&2
  if [[ "$pane_cleanup" == "1" ]]; then
    if run_with_cleanup "${wrapped_cmd[@]}"; then
      status=0
    else
      status=$?
    fi
    exit "$status"
  fi
  exec "${wrapped_cmd[@]}"
fi

conf="${AOC_AGENT_TMUX_CONF:-${XDG_CONFIG_HOME:-$HOME/.config}/aoc/codex-tmux.conf}"
socket="aoc-${agent_id}-${ZELLIJ_PANE_ID:-$$}"
session="$agent_id"
socket_dir="/tmp/tmux-$(id -u)"
socket_path="$socket_dir/$socket"

# Clean up stale sockets that block tmux from starting.
if [[ -S "$socket_path" ]]; then
  if ! tmux -L "$socket" ls >/dev/null 2>&1; then
    rm -f "$socket_path"
  fi
fi

if [[ -f "$conf" ]]; then
  tmux_cmd=(tmux -L "$socket" -f "$conf" new-session -A -s "$session" "${wrapped_cmd[@]}")
else
  tmux_cmd=(tmux -L "$socket" new-session -A -s "$session" "${wrapped_cmd[@]}")
fi

if [[ "$pane_cleanup" == "1" ]]; then
  if run_with_cleanup "${tmux_cmd[@]}"; then
    status=0
  else
    status=$?
  fi
  exit "$status"
fi

exec "${tmux_cmd[@]}"
