#!/usr/bin/env bash
set -euo pipefail

if [[ $# -lt 1 ]]; then
  echo "Usage: aoc-rtk-proxy <command> [args...]" >&2
  exit 2
fi

script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
command_name="$1"
shift

if [[ "$command_name" == "aoc-rtk" || "$command_name" == "aoc-rtk-proxy" ]]; then
  echo "aoc-rtk-proxy: refusing to route internal command '$command_name'" >&2
  exit 126
fi

resolve_passthrough_bin() {
  local cmd="$1"

  if [[ "$cmd" == */* ]]; then
    if [[ -x "$cmd" ]]; then
      printf '%s' "$cmd"
      return 0
    fi
    return 1
  fi

  local part=""
  local candidate=""
  IFS=':' read -r -a parts <<<"$PATH"
  for part in "${parts[@]}"; do
    [[ -n "$part" ]] || continue
    if [[ -n "${AOC_RTK_SHIM_DIR:-}" && "$part" == "$AOC_RTK_SHIM_DIR" ]]; then
      continue
    fi
    candidate="$part/$cmd"
    if [[ -x "$candidate" ]]; then
      printf '%s' "$candidate"
      return 0
    fi
  done

  return 1
}

run_passthrough() {
  local cmd="$1"
  shift
  local target=""
  if ! target="$(resolve_passthrough_bin "$cmd")"; then
    echo "$cmd: command not found" >&2
    return 127
  fi
  exec "$target" "$@"
}

unshimmed_path() {
  local original_path="$1"
  local filtered=()
  local part=""

  IFS=':' read -r -a parts <<<"$original_path"
  for part in "${parts[@]}"; do
    [[ -n "$part" ]] || continue
    if [[ -n "${AOC_RTK_SHIM_DIR:-}" && "$part" == "$AOC_RTK_SHIM_DIR" ]]; then
      continue
    fi
    filtered+=("$part")
  done

  if [[ ${#filtered[@]} -eq 0 ]]; then
    printf '%s' "$original_path"
    return
  fi

  local joined=""
  local item=""
  for item in "${filtered[@]}"; do
    if [[ -z "$joined" ]]; then
      joined="$item"
    else
      joined="$joined:$item"
    fi
  done
  printf '%s' "$joined"
}

is_truthy() {
  local value="${1:-}"
  value="$(printf '%s' "$value" | tr '[:upper:]' '[:lower:]')"
  case "$value" in
    1|true|yes|on) return 0 ;;
    *) return 1 ;;
  esac
}

if is_truthy "${AOC_RTK_BYPASS:-0}" || [[ "${AOC_RTK_MODE:-}" == "off" ]]; then
  run_passthrough "$command_name" "$@"
fi

rtk_ctl="$script_dir/aoc-rtk"
if [[ ! -x "$rtk_ctl" ]]; then
  rtk_ctl="$(command -v aoc-rtk 2>/dev/null || true)"
fi
if [[ -z "$rtk_ctl" ]]; then
  run_passthrough "$command_name" "$@"
fi

safe_path="$(unshimmed_path "$PATH")"

sanitize_component() {
  local input="$1"
  local output
  output="$(printf '%s' "$input" | tr -c 'A-Za-z0-9._-' '_')"
  printf '%s' "${output:-unknown}"
}

status_cache_ttl_raw="${AOC_RTK_STATUS_CACHE_TTL_SECS:-5}"
status_cache_ttl=5
if [[ "$status_cache_ttl_raw" =~ ^[0-9]+$ ]]; then
  status_cache_ttl="$status_cache_ttl_raw"
fi

cache_root="${XDG_RUNTIME_DIR:-/tmp}/aoc-rtk-status"
cache_scope="$(sanitize_component "${AOC_SESSION_ID:-nosession}-${AOC_PANE_ID:-nopane}")"
cache_file="$cache_root/${cache_scope}.shell"
cache_lock_dir="$cache_root/${cache_scope}.lock"

acquire_status_lock() {
  local attempts="${AOC_RTK_STATUS_LOCK_ATTEMPTS:-25}"
  local sleep_secs="${AOC_RTK_STATUS_LOCK_SLEEP_SECS:-0.02}"
  local attempt=0

  while (( attempt < attempts )); do
    if mkdir "$cache_lock_dir" 2>/dev/null; then
      return 0
    fi

    # If another process refreshed the cache while we waited, skip refresh.
    if read_cached_status >/dev/null 2>&1; then
      return 1
    fi

    sleep "$sleep_secs"
    attempt=$((attempt + 1))
  done

  return 1
}

release_status_lock() {
  rmdir "$cache_lock_dir" 2>/dev/null || true
}

read_cached_status() {
  local now="$(date +%s)"
  local mtime="0"
  local cached=""
  if [[ ! -f "$cache_file" ]]; then
    return 1
  fi
  mtime="$(stat -c %Y "$cache_file" 2>/dev/null || stat -f %m "$cache_file" 2>/dev/null || printf '0')"
  if [[ ! "$mtime" =~ ^[0-9]+$ ]]; then
    return 1
  fi
  if (( now - mtime > status_cache_ttl )); then
    return 1
  fi
  cached="$(<"$cache_file")"
  printf '%s' "$cached"
}

refresh_status() {
  local status=""
  status="$(AOC_RTK_BYPASS=1 PATH="$safe_path" "$rtk_ctl" status --shell 2>/dev/null || true)"
  if [[ -n "$status" ]]; then
    mkdir -p "$cache_root" 2>/dev/null || true
    printf '%s\n' "$status" >"$cache_file" 2>/dev/null || true
  fi
  printf '%s' "$status"
}

resolve_status_shell() {
  local status=""

  status="$(read_cached_status || true)"
  if [[ -n "$status" ]]; then
    printf '%s' "$status"
    return
  fi

  if acquire_status_lock; then
    status="$(read_cached_status || true)"
    if [[ -z "$status" ]]; then
      status="$(refresh_status || true)"
    fi
    release_status_lock
    printf '%s' "$status"
    return
  fi

  # Lock contention path: prefer cached status, else fail-open to passthrough.
  status="$(read_cached_status || true)"
  printf '%s' "$status"
}

status_shell=""
if [[ "${AOC_RTK_MODE:-}" == "on" && -n "${AOC_RTK_ALLOWLIST:-}" ]]; then
  status_shell="mode=${AOC_RTK_MODE:-on}
fail_open=${AOC_RTK_FAIL_OPEN:-1}
gain_mode=${AOC_RTK_GAIN_MODE:-double-dash}
binary=${AOC_RTK_BINARY:-rtk}"

  while IFS= read -r line; do
    [[ -n "$line" ]] || continue
    status_shell+="
allow=$line"
  done <<<"${AOC_RTK_ALLOWLIST:-}"

  while IFS= read -r line; do
    [[ -n "$line" ]] || continue
    status_shell+="
deny=$line"
  done <<<"${AOC_RTK_DENYLIST:-}"
else
  status_shell="$(resolve_status_shell)"
fi

if [[ -z "$status_shell" ]]; then
  run_passthrough "$command_name" "$@"
fi

mode="off"
fail_open="1"
gain_mode="double-dash"
binary="rtk"
allowlist=()
denylist=()

line=""
key=""
value=""
while IFS= read -r line; do
  [[ -n "$line" ]] || continue
  key="${line%%=*}"
  value="${line#*=}"
  case "$key" in
    mode) mode="$value" ;;
    fail_open) fail_open="$value" ;;
    gain_mode) gain_mode="$value" ;;
    binary) binary="$value" ;;
    allow) allowlist+=("$value") ;;
    deny) denylist+=("$value") ;;
    *) ;;
  esac
done <<<"$status_shell"

if [[ "$mode" != "on" ]]; then
  run_passthrough "$command_name" "$@"
fi

full_command="$command_name"
arg=""
for arg in "$@"; do
  full_command="$full_command $arg"
done

allowed=0
pattern=""
for pattern in "${allowlist[@]}"; do
  if [[ "$full_command" == "$pattern" || "$full_command" == "$pattern "* ]]; then
    allowed=1
    break
  fi
done
if [[ "$allowed" != "1" ]]; then
  run_passthrough "$command_name" "$@"
fi

for pattern in "${denylist[@]}"; do
  if [[ "$full_command" == "$pattern" || "$full_command" == "$pattern "* ]]; then
    run_passthrough "$command_name" "$@"
  fi
done

binary="${AOC_RTK_BINARY:-$binary}"
if ! command -v "$binary" >/dev/null 2>&1; then
  run_passthrough "$command_name" "$@"
fi

rtk_common_flags=()
if is_truthy "${AOC_RTK_ULTRA_COMPACT:-0}"; then
  rtk_common_flags+=(-u)
fi

resolved_bin=""
if ! resolved_bin="$(resolve_passthrough_bin "$command_name")"; then
  echo "$command_name: command not found" >&2
  exit 127
fi

# Preserve native stdin behavior for heredocs/pipes/process substitution.
# Optional opt-in allows routing in non-interactive command runners that use
# non-tty stdin without actual piped/file payloads.
if [[ ! -t 0 ]]; then
  if ! is_truthy "${AOC_RTK_ROUTE_NON_TTY_STDIN:-0}"; then
    exec env AOC_RTK_BYPASS=1 PATH="$safe_path" "$resolved_bin" "$@"
  fi
  if [[ -p /dev/stdin || -f /dev/stdin ]]; then
    exec env AOC_RTK_BYPASS=1 PATH="$safe_path" "$resolved_bin" "$@"
  fi
fi

# Prompt/status commands can fire very frequently; keep them native.
if [[ "$command_name" == "git" && "${1:-}" == "rev-parse" ]]; then
  exec env AOC_RTK_BYPASS=1 PATH="$safe_path" "$resolved_bin" "$@"
fi

if [[ "$command_name" == "git" && "${1:-}" == "status" ]]; then
  case "${2:-}" in
    --porcelain*|--short|-s)
      exec env AOC_RTK_BYPASS=1 PATH="$safe_path" "$resolved_bin" "$@"
      ;;
  esac
fi

if [[ "$command_name" == "git" && "${1:-}" == "diff" ]]; then
  case "${2:-}" in
    --numstat|--shortstat)
      exec env AOC_RTK_BYPASS=1 PATH="$safe_path" "$resolved_bin" "$@"
      ;;
  esac
fi

effective_gain_mode="${AOC_RTK_GAIN_MODE:-$gain_mode}"
route_cmd=()
if "$binary" proxy --help >/dev/null 2>&1; then
  if "$binary" help "$command_name" >/dev/null 2>&1; then
    route_cmd=("$binary" "${rtk_common_flags[@]}" "$command_name" "$@")
  else
    route_cmd=("$binary" "${rtk_common_flags[@]}" proxy "$resolved_bin" "$@")
  fi
else
  route_cmd=("$binary" "${rtk_common_flags[@]}" gain)
  if [[ "$effective_gain_mode" == "positional" ]]; then
    route_cmd+=("$resolved_bin" "$@")
  else
    route_cmd+=(-- "$resolved_bin" "$@")
  fi
fi

if AOC_RTK_BYPASS=1 PATH="$safe_path" "${route_cmd[@]}"; then
  exit 0
fi

route_status=$?
if is_truthy "${AOC_RTK_FAIL_OPEN:-$fail_open}"; then
  exec env AOC_RTK_BYPASS=1 PATH="$safe_path" "$resolved_bin" "$@"
fi

exit "$route_status"
