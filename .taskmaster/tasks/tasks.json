{
  "master": {
    "tasks": [
      {
        "id": "1",
        "title": "Add aoc-doctor dependency checker",
        "description": "Create a script that validates required tools (zellij, yazi, fzf, chafa, ffmpeg, poppler-utils, librsvg2-bin, rg, bat, tectonic) and prints actionable install hints.",
        "details": "Add bin/aoc-doctor and document in README.md; include exit codes and a --quiet mode for CI.",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Define dependency list and install hints",
            "description": "Classify required vs optional tools and map each to distro-specific install hints for README and aoc-doctor output.",
            "status": "pending",
            "dependencies": []
          },
          {
            "id": 2,
            "title": "Implement bin/aoc-doctor with exit codes",
            "description": "Create aoc-doctor that checks PATH/tools, supports --quiet, and returns non-zero on missing required deps.",
            "status": "pending",
            "dependencies": []
          },
          {
            "id": 3,
            "title": "Document doctor usage",
            "description": "Add README section with example output and suggested install fixes.",
            "status": "pending",
            "dependencies": []
          }
        ],
        "updatedAt": "2026-01-17T16:52:06.071Z",
        "activeAgent": false
      },
      {
        "id": "2",
        "title": "Improve aoc-taskmaster interactivity",
        "description": "Enhance the Taskmaster pane UX with actions to mark done, open details, and refresh lists.",
        "details": "Add key bindings in bin/aoc-taskmaster (e.g., enter to open, d to mark done, r to refresh) and handle missing task-master-ai gracefully.",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Detect missing task-master-ai",
            "description": "Add graceful fallback when TM binary is missing (message + exit or read-only mode).",
            "status": "pending",
            "dependencies": []
          },
          {
            "id": 2,
            "title": "Add task actions in UI",
            "description": "Implement keybinds to mark done/reopen, open task details, and refresh without restarting.",
            "status": "pending",
            "dependencies": []
          },
          {
            "id": 3,
            "title": "Update help text and keybinds",
            "description": "Keep the on-screen hints aligned with the new actions and modes.",
            "status": "pending",
            "dependencies": []
          }
        ],
        "updatedAt": "2026-01-06T17:03:04.695Z",
        "activeAgent": false
      },
      {
        "id": "3",
        "title": "Widget resilience and UX polish",
        "description": "Improve aoc-widget to handle missing tools and invalid media paths with clear prompts.",
        "details": "Add detection for chafa/ffmpeg/rsvg-convert and show fallback text; persist last mode in state file.",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Persist widget mode",
            "description": "Store last mode (cal/media) in state file and restore on start.",
            "status": "pending",
            "dependencies": []
          },
          {
            "id": 2,
            "title": "Add tool checks and fallbacks",
            "description": "Detect chafa/ffmpeg/rsvg-convert and show clear fallback instructions.",
            "status": "pending",
            "dependencies": []
          },
          {
            "id": 3,
            "title": "Improve path selection flow",
            "description": "Add validation and non-blocking prompt when media path is missing or unsupported.",
            "status": "pending",
            "dependencies": []
          }
        ],
        "updatedAt": "2026-01-06T17:03:06.117Z",
        "activeAgent": false
      },
      {
        "id": "4",
        "title": "Sys details configurability",
        "description": "Allow aoc-sys to be configured for update interval and sections.",
        "details": "Support env vars like AOC_SYS_INTERVAL and toggles for CPU/mem/disk output.",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Add env var support",
            "description": "Implement AOC_SYS_INTERVAL and section toggles (CPU/Mem/Disk) with defaults.",
            "status": "pending",
            "dependencies": []
          },
          {
            "id": 2,
            "title": "Update sys output formatting",
            "description": "Keep output stable for small panes; handle missing /proc gracefully.",
            "status": "pending",
            "dependencies": []
          },
          {
            "id": 3,
            "title": "Document aoc-sys configuration",
            "description": "Add README section with env vars and examples.",
            "status": "pending",
            "dependencies": []
          }
        ],
        "updatedAt": "2026-01-06T17:03:06.731Z",
        "activeAgent": false
      },
      {
        "id": "5",
        "title": "Layout customization options",
        "description": "Allow users to override pane sizes and commands without editing aoc.kdl directly.",
        "details": "Document environment variables or alternate layout file strategy in README.md; consider templating in install.sh.",
        "testStrategy": "",
        "status": "pending",
        "dependencies": [],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Choose customization strategy",
            "description": "Decide between env var overrides or templated layout copy on install.",
            "status": "done",
            "dependencies": []
          },
          {
            "id": 2,
            "title": "Implement override mechanism",
            "description": "Add layout templating or alternate layout file resolution in install/launch.",
            "status": "done",
            "dependencies": []
          },
          {
            "id": 3,
            "title": "Document layout overrides",
            "description": "Provide examples for custom sizes/commands in README.",
            "status": "done",
            "dependencies": []
          }
        ],
        "updatedAt": "2026-01-06T17:03:07.336Z",
        "activeAgent": false
      },
      {
        "id": "6",
        "title": "Installer improvements and uninstall path",
        "description": "Add an uninstall script and make install.sh idempotent with clear output.",
        "details": "Add bin/aoc-uninstall or scripts/uninstall.sh; ensure it removes only files installed by AOC.",
        "testStrategy": "",
        "status": "pending",
        "dependencies": [],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Add uninstall script",
            "description": "Create aoc-uninstall or scripts/uninstall.sh to remove installed files only.",
            "status": "pending",
            "dependencies": []
          },
          {
            "id": 2,
            "title": "Make installer idempotent",
            "description": "Ensure install.sh overwrites safely, prints what changed, and exits cleanly on re-run.",
            "status": "pending",
            "dependencies": []
          },
          {
            "id": 3,
            "title": "Document install/uninstall",
            "description": "Add README usage examples and expected file paths.",
            "status": "pending",
            "dependencies": []
          }
        ],
        "updatedAt": "2026-01-06T17:03:08.164Z",
        "activeAgent": false
      },
      {
        "id": "7",
        "title": "README enhancements and troubleshooting",
        "description": "Add setup verification, troubleshooting, and screenshot usage guidance.",
        "details": "Include common failures (missing chafa, yazi preview) and how to fix; add placeholder for screenshot.",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Add setup verification checklist",
            "description": "Document a quick checklist (zellij version, yazi preview, widget media) and how to confirm.",
            "status": "pending",
            "dependencies": []
          },
          {
            "id": 2,
            "title": "Add troubleshooting section",
            "description": "Cover common errors (missing tools, blank preview, taskmaster missing) with fixes.",
            "status": "pending",
            "dependencies": []
          },
          {
            "id": 3,
            "title": "Add screenshot guidance",
            "description": "Include placeholder path and note for updating the screenshot in README.",
            "status": "pending",
            "dependencies": []
          }
        ],
        "updatedAt": "2026-01-06T17:03:09.086Z",
        "activeAgent": false
      },
      {
        "id": "8",
        "title": "Add shellcheck lint workflow",
        "description": "Introduce a lightweight CI or local script to run shellcheck on bin/ and yazi/preview.sh.",
        "details": "Add scripts/lint.sh or a GitHub Actions workflow; document in README.md.",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Create scripts/lint.sh",
            "description": "Add shellcheck invocation over bin/ and yazi/preview.sh with sensible flags.",
            "status": "pending",
            "dependencies": []
          },
          {
            "id": 2,
            "title": "Add GitHub Actions lint workflow",
            "description": "Optional CI workflow that runs shellcheck on pushes/PRs.",
            "status": "pending",
            "dependencies": []
          },
          {
            "id": 3,
            "title": "Document lint usage",
            "description": "Add README instructions for running lint locally and in CI.",
            "status": "pending",
            "dependencies": []
          }
        ],
        "updatedAt": "2026-01-06T17:03:10.110Z",
        "activeAgent": false
      },
      {
        "id": "9",
        "title": "Versioning and release notes",
        "description": "Define a minimal versioning scheme and CHANGELOG.md.",
        "details": "Add CHANGELOG.md and update README.md with release process; optional tag naming.",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Create CHANGELOG.md",
            "description": "Add initial release section describing current features.",
            "status": "pending",
            "dependencies": []
          },
          {
            "id": 2,
            "title": "Define versioning scheme",
            "description": "Document SemVer (or similar) and tag naming in README.",
            "status": "pending",
            "dependencies": []
          },
          {
            "id": 3,
            "title": "Add release checklist",
            "description": "Add a small checklist for cutting releases and tagging.",
            "status": "pending",
            "dependencies": []
          }
        ],
        "updatedAt": "2026-01-06T17:03:11.326Z",
        "activeAgent": false
      },
      {
        "id": "10",
        "title": "Zellij Taskmaster plugin (realtime tasks panel)",
        "description": "Design and implement a Zellij plugin that renders Task Master tasks in realtime from .taskmaster/tasks/tasks.json and wires CLI actions (task-master) for updates.",
        "details": "",
        "testStrategy": "Manual: launch zellij layout with plugin pane; verify realtime updates on tasks.json changes and basic actions (filter, show details, set status).",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Collect Task Master schema + CLI usage for renderer/actions",
            "description": "Summarize tasks.json schema and relevant CLI commands (list/show/set-status/update/add/remove) to support plugin rendering and actions.",
            "status": "done",
            "dependencies": []
          },
          {
            "id": 2,
            "title": "Evaluate Zellij plugin API + integration points",
            "description": "Confirm zellij-tile capabilities (events, workers, filesystem access) and how to ship/load plugin in this repo.",
            "status": "done",
            "dependencies": []
          },
          {
            "id": 3,
            "title": "Design plugin UX + state model",
            "description": "Define list/detail views, filters, keybindings, realtime refresh strategy, and error states (missing tasks.json, parse errors).",
            "status": "done",
            "dependencies": []
          },
          {
            "id": 4,
            "title": "Scaffold plugin project + build pipeline",
            "description": "Add plugin source (Rust/WASM), build scripts, and install integration for zellij config/layout.",
            "status": "done",
            "dependencies": []
          },
          {
            "id": 5,
            "title": "Implement realtime renderer + file watcher/polling",
            "description": "Load tasks.json, parse tasks/subtasks, render list/detail, and refresh on interval or file mtime change.",
            "status": "done",
            "dependencies": []
          },
          {
            "id": 6,
            "title": "Wire CLI actions (status changes, open details)",
            "description": "Integrate task-master CLI commands for status changes and task updates; handle errors gracefully.",
            "status": "done",
            "dependencies": []
          },
          {
            "id": 7,
            "title": "Update docs + install instructions",
            "description": "Document plugin build/install, configuration, and keybindings in README; update install/uninstall as needed.",
            "status": "done",
            "dependencies": []
          }
        ],
        "updatedAt": "2026-01-09T07:01:13.182Z",
        "activeAgent": false
      },
      {
        "id": "11",
        "title": "Refactor Taskmaster Plugin: Modularize Monolithic main.rs",
        "description": "Refactor the existing monolithic main.rs in the Taskmaster Zellij plugin into distinct modules (model, state, ui) to improve maintainability and separation of concerns.",
        "details": "The current implementation of the Taskmaster plugin resides almost entirely in `plugins/taskmaster/src/main.rs`. To improve code organization and testability, the code should be split into logical modules.\n\n### Proposed Structure:\n1. **`src/model.rs`**: Move data structures here, specifically the `Task`, `TaskStatus`, and any serialization/deserialization logic (Serde structs).\n2. **`src/state.rs`**: encapsulate the application state logic. Move the `State` struct and its implementation (e.g., loading tasks from JSON, filtering logic, selection handling) here.\n3. **`src/ui.rs`**: Isolate rendering logic. Move the `render` function and any helper functions related to UI layout (e.g., calculating rows, drawing the header/footer) here.\n4. **`src/main.rs`**: Should become a thin entry point that initializes the `State`, handles the Zellij event loop (`update` method), and delegates rendering to `ui`.\n\n### Implementation Steps:\n- Create the new module files in `plugins/taskmaster/src/`.\n- Iteratively move code from `main.rs` to the respective modules, fixing visibility (`pub`) issues.\n- Ensure `Cargo.toml` dependencies (like `serde`, `zezellij-tile`) are accessible where needed.\n- Verify that the logic for loading `.taskmaster/tasks/tasks.json` remains intact in the `state` module.",
        "testStrategy": "1. **Compilation Check**: Ensure `cargo build --release --target wasm32-wasi` succeeds without errors.\n2. **Functional Verification**: Load the refactored plugin in Zellij. Verify that tasks still load correctly, navigation works (up/down), and filtering toggles work exactly as before.\n3. **Regression Test**: Confirm that no features from Task #10 (rendering, key updates) were lost during the refactor.",
        "status": "done",
        "dependencies": [
          "10"
        ],
        "priority": "high",
        "subtasks": [],
        "updatedAt": "2026-01-11T22:02:37.273Z",
        "activeAgent": false
      },
      {
        "id": "12",
        "title": "Implement UI Primitives: Table and ProgressBar for TUI",
        "description": "Create reusable `Table` and `ProgressBar` structs within the `ui` module of the Taskmaster plugin to standardize rendering of tabular data and progress indicators.",
        "details": "This task focuses on abstracting rendering logic into reusable components within `plugins/taskmaster/src/ui.rs` (or a sub-module like `ui/widgets.rs`). \n\n### Implementation Requirements:\n1. **ProgressBar Struct**:\n   - Fields: `progress` (f32 or usize), `total` (usize), `width` (usize), and styling characters (e.g., full block, empty block).\n   - Method `render(&self) -> String`: Returns a string representation of the bar (e.g., `[‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë] 40%`).\n   - Should handle boundary conditions (0% and 100%).\n\n2. **Table Struct**:\n   - Design a struct that accepts headers and a list of rows.\n   - Support dynamic column width calculation based on content or fixed constraints.\n   - Method `render(&self) -> Vec<String>` or similar, yielding lines ready to be printed to the TUI buffer.\n   - Ensure alignment support (left/right/center) if feasible.\n\n3. **Integration**:\n   - Update the main rendering loop to use these new primitives instead of raw string formatting where applicable (e.g., displaying the task list as a table, showing completion status as a progress bar).\n   - Ensure these structs implement `Display` or specific render traits compatible with `zellij-tile`.\n\n### Codebase Alignment:\n- Place code in `src/ui.rs` if it exists (post-Task 11) or prepare it to be moved there.\n- Ensure compatibility with existing color definitions in the `State` or `Model`.",
        "testStrategy": "1. **Unit Tests**: Create unit tests in `src/ui.rs` for `ProgressBar` verifying output strings for 0%, 50%, and 100% progress. Test `Table` rendering with varying row lengths.\n2. **Visual Verification**: Temporarily modify the plugin's `render` method to display a static table and progress bar to verify alignment and visual style within Zellij.\n3. **Edge Cases**: Verify behavior when table content exceeds pane width (truncation vs wrapping).",
        "status": "done",
        "dependencies": [
          "10",
          "11"
        ],
        "priority": "high",
        "subtasks": [],
        "updatedAt": "2026-01-11T22:03:34.833Z",
        "activeAgent": false
      },
      {
        "id": "13",
        "title": "Implement Theme System (plugins/taskmaster): Add Nerd Fonts and Color Palette support",
        "description": "Introduce a centralized theme configuration to `plugins/taskmaster` providing semantic color palettes and Nerd Font icons for task statuses and UI elements.",
        "details": "This task focuses on decoupling hardcoded styles and icons from the rendering logic by introducing a `Theme` struct. This will improve consistency and allow for easier customization or future configuration.\n\n### Implementation Requirements:\n1. **Create `src/theme.rs`**:\n   - Define a `Theme` struct containing palette fields (e.g., `primary`, `success`, `warning`, `error`, `text_dim`) utilizing `zellij_tile::prelude::*` colors or ANSI codes.\n   - Define an `Icons` struct or fields within `Theme` for status icons (e.g., pending: `‚óã` / `ÔÑå`, active: `‚ñ∂` / `ÔÜí`, done: `‚úî` / `ÔÅò`, blocked: `‚úñ` / `ÔÅó`).\n   - Implement a default implementation for `Theme` that uses a standard color scheme (e.g., Catppuccin-inspired or system default) and Nerd Fonts if supported (consider a flag or default to yes).\n\n2. **Integrate Theme into State/UI**:\n   - Add `theme: Theme` to the plugin's `State` struct.\n   - Update `src/ui.rs` (or rendering logic in `main.rs` if not yet refactored) to use `state.theme` instead of hardcoded strings/colors.\n   - Replace manual `format!` calls having raw color codes with helper methods from the `Theme` (e.g., `theme.style_status(&task.status)`).\n\n3. **Iconography**:\n   - Ensure the chosen Nerd Font glyphs are standard and widely supported.\n   - Update the task list rendering to prefix tasks with their status icon.\n   - Update the status bar/footer to use icons for hints (e.g., `?` for help, `‚Üª` for refresh).\n\n4. **Refactor Compatibility**:\n   - If Task 12 (UI Primitives) is complete, ensure `Table` and `ProgressBar` accept style definitions from the `Theme`.",
        "testStrategy": "1. **Visual Verification**: Launch the plugin in Zellij and verify that colors match the defined palette and icons render correctly (requires a Nerd Font patched terminal).\n2. **State Check**: Ensure the theme loads correctly on plugin start.\n3. **Regression Test**: Verify that text content remains readable and alignment is preserved with the addition of icons (which can sometimes be double-width).",
        "status": "done",
        "dependencies": [
          "11"
        ],
        "priority": "medium",
        "subtasks": [],
        "updatedAt": "2026-01-11T22:05:07.218Z",
        "activeAgent": false
      },
      {
        "id": "14",
        "title": "Implement Dashboard Layout (plugins/taskmaster): Build Header HUD and Task Grid",
        "description": "Construct the main dashboard interface for the Taskmaster plugin by implementing a Header HUD for status summaries and a Task Grid for the main task list, utilizing the newly created UI primitives and theme system.",
        "details": "This task integrates the modular components created in previous tasks to build the final UI layout. The layout will be divided into two main sections: a Header HUD (Heads-Up Display) and a scrollable Task Grid.\n\n### Implementation Requirements:\n\n1. **Modify `src/ui.rs` (or `src/ui/layout.rs`)**:\n   - Implement a `draw_dashboard` function that accepts `&State`, `&Theme`, and `&mut UiWriter`.\n\n2. **Implement Header HUD**:\n   - **Layout**: Top section of the screen (fixed height, e.g., 3-4 rows).\n   - **Components**: \n     - **Progress Bar**: Use the `ProgressBar` struct (Task 12) to show overall completion (completed tasks / total tasks).\n     - **Stats**: Display counts for 'Pending', 'In Progress', 'Done' using theme colors (Task 13) (e.g., Green for Done, Yellow for In Progress).\n     - **Filter Status**: Show current active filter.\n\n3. **Implement Task Grid**:\n   - **Layout**: Remaining vertical space below the header.\n   - **Component**: Use the `Table` struct (Task 12) to render the list of tasks.\n   - **Columns**: ID, Status icon (Nerd Font from Task 13), Title, Priority, Age (calculated from timestamp).\n   - **Selection**: Highlight the currently selected row using the Theme's selection color.\n   - **Scrolling**: Ensure the table renders a window of tasks based on `state.selected_index` and available height.\n\n4. **Integration**:\n   - Update the main render loop in `main.rs` (or `lib.rs`) to call `draw_dashboard` instead of the legacy rendering logic.\n\n### Code Reference:\n- Utilize `zellij_tile::prelude::*` for coordinate management.\n- Access state properties from `State` struct (refactored in Task 11).",
        "testStrategy": "1. **Visual Layout Verification**: Run the plugin in Zellij and verify the screen is split into Header and Grid.\n2. **Data Consistency**: Check that the Header stats (e.g., '3/10 Done') match the actual rows in the Task Grid.\n3. **Selection & Scrolling**: Navigate up/down through the list; verify the highlight moves and the table scrolls when the selection goes off-screen.\n4. **Theme Verification**: Confirm that status icons and colors from Task 13 are correctly applied to the rows.",
        "status": "done",
        "dependencies": [
          "11",
          "12",
          "13"
        ],
        "priority": "high",
        "subtasks": [],
        "updatedAt": "2026-01-11T22:07:38.663Z",
        "activeAgent": false
      },
      {
        "id": "15",
        "title": "Implement Sub-task Rendering (plugins/taskmaster): Visualize nested subtasks in the details pane",
        "description": "Enhance the details pane in the Taskmaster plugin to recursively render subtasks with status indicators and progress bars.",
        "details": "This task involves updating the UI rendering logic to properly display nested subtasks when a user inspects a specific task. The `Task` model already contains a `subtasks` field (Vec<Task>), and this structure needs to be traversed and visualized.\n\n### Implementation Requirements:\n\n1.  **Modify `src/ui.rs` - `draw_details_pane`**:\n    - Locate the function responsible for drawing task details (likely stubbed or basic).\n    - Implement a recursive or iterative rendering strategy to display subtasks.\n    - **Indentation**: Visual hierarchy should be clear. Use spaces or tree branches (e.g., `‚îú‚îÄ`, `‚îî‚îÄ`) to denote depth.\n    - **Status Icons**: Use the `Theme` system to render status icons (e.g., checkmark for Done, spinner for In Progress) for each subtask.\n\n2.  **Progress Calculation**:\n    - Implement a helper method on `Task` (e.g., `calculate_progress() -> f32`) that recursively calculates completion percentage based on subtasks.\n    - Integrate the `ProgressBar` component (created in Task 12) into the details header or alongside complex subtask groups to show aggregate progress.\n\n3.  **Interaction Handling (if applicable)**:\n    - Ensure the scrolling logic in the details pane accommodates the potentially long list of subtasks.\n\n### Code Integration:\n- **Model**: Ensure `Task` struct in `src/model.rs` derives necessary traits (Clone, Debug) to be passed to the renderer easily.\n- **Theme**: Use `theme.icons.subtask_branch` (or similar) and colors defined in Task 13 for consistent styling.",
        "testStrategy": "1. **Data Mocking**: Create a `tasks.json` with deep nesting (e.g., Task -> Subtask A -> Subtask A.1).\n2. **Visual Verification**: Open the details pane for the nested task. Verify indentation is correct and tree structure is readable.\n3. **Progress Check**: Verify that the progress bar correctly reflects the ratio of completed subtasks.\n4. **Theme Check**: Ensure icons and colors for subtasks match the configured theme.",
        "status": "done",
        "dependencies": [
          "12",
          "13",
          "14"
        ],
        "priority": "medium",
        "subtasks": [],
        "updatedAt": "2026-01-12T06:21:59.249Z",
        "activeAgent": false
      },
      {
        "id": "16",
        "title": "Implement Search/Filter Logic (plugins/taskmaster)",
        "description": "Add interactive filtering capabilities to the Taskmaster plugin, supporting text search via '/' and status filter cycling via 'f'.",
        "details": "This task focuses on enhancing the `update` loop and `State` management in `plugins/taskmaster` to support dynamic filtering of the task list.\n\n### Implementation Requirements\n\n1.  **Update `State` Struct (`src/state.rs`)**:\n    - Add `filter_query: String` to store the active text search input.\n    - Add `filter_status: Option<TaskStatus>` (or an enum wrapping it) to store the active status filter (e.g., All, Pending, In Progress, Done).\n    - Add a boolean flag `is_searching` or `input_mode` to distinguish between navigation mode and text input mode.\n\n2.  **Modify `update` Function (`src/main.rs`)**:\n    - **'/' Key**: Toggle `is_searching` mode to true. While in search mode, capture character inputs to append to `filter_query`.\n    - **'Esc' / 'Enter'**: Exit search mode. 'Esc' could clear the query or just cancel typing.\n    - **'f' Key**: Cycle through available `TaskStatus` values (All -> Pending -> In Progress -> Done -> All).\n    - **Backspace**: Handle character deletion when in search mode.\n\n3.  **Implement Filtering Logic**:\n    - Create a method `get_filtered_tasks(&self) -> Vec<&Task>` on the `State` struct.\n    - This method should filter `self.tasks` based on:\n      - Does `task.title` (or description) contain `filter_query` (case-insensitive)?\n      - Does `task.status` match `filter_status` (if set)?\n\n4.  **UI Updates (`src/ui.rs`)**:\n    - Update the rendering loop to use `get_filtered_tasks()` instead of the raw task list for the main grid.\n    - **Search Bar**: Render a search input field (perhaps in the Header HUD or a bottom bar) when `is_searching` is active or `filter_query` is not empty.\n    - **Filter Indicator**: Display the current status filter in the HUD (e.g., \"[Filter: Pending]\").",
        "testStrategy": "1. **Unit Tests**: Test `get_filtered_tasks` logic in `state.rs` with various combinations of query strings and status filters to ensure accurate subsetting.\n2. **Interactive Search**: Run the plugin, press '/', type a partial task name, and verify the grid updates in real-time to show only matching tasks.\n3. **Status Cycling**: Press 'f' repeatedly and verify the grid toggles between showing all tasks and specific statuses.\n4. **Input Handling**: Verify Backspace works correctly and Esc exits search mode without crashing.",
        "status": "done",
        "dependencies": [
          "11",
          "14",
          "15"
        ],
        "priority": "high",
        "subtasks": [],
        "updatedAt": "2026-01-12T06:22:12.353Z",
        "activeAgent": false
      },
      {
        "id": "17",
        "title": "Implement 'Assign to Agent' (plugins/taskmaster): Add 'a' key to tag tasks for active agent focus",
        "description": "Add functionality to toggle an 'active_agent' tag on tasks using the 'a' key, allowing users to designate specific tasks for immediate AI agent attention.",
        "details": "This task implements a tagging mechanism to mark tasks for active agent focus. This involves updating the data model, state management, and input handling within the Taskmaster plugin.\n\n### Implementation Requirements:\n\n1.  **Update Data Model (`src/task.rs` or `src/state.rs`)**:\n    - Add a field `pub active_agent: bool` (defaulting to false) to the `Task` struct.\n    - If `Task` is defined in an external crate (like `task_master_core` referenced in previous tasks), ensure this field is added there or managed locally in the plugin state if the core struct is immutable.\n    - Ensure serialization/deserialization logic handles this new field (e.g., `#[serde(default)]`).\n\n2.  **Modify State Management (`src/state.rs`)**:\n    - Implement a method `toggle_agent_focus(&mut self)` on the `State` struct.\n    - This method should locate the currently selected task (based on `selected_index`) and toggle its `active_agent` boolean.\n    - Persist the change back to `tasks.json` immediately to trigger any file watchers or external agent processes.\n\n3.  **Update Input Handling (`src/main.rs`)**:\n    - In the `update` loop (specifically inside the `Key::Char('a')` match arm):\n      - Call `state.toggle_agent_focus()`.\n      - Ensure the UI refreshes to reflect the change.\n\n4.  **UI Visualization (`src/ui.rs`)**:\n    - Update the task list rendering to visually distinguish tasks with `active_agent: true`.\n    - Use a specific icon (e.g., `ü§ñ` or a specific nerd font glyph) or a color highlight (e.g., Magenta/Purple from the Theme) next to the task status or title.\n    - Ensure the visual indicator is distinct from standard status icons.",
        "testStrategy": "1. **Unit Tests**: Test `toggle_agent_focus` in `state.rs` to verify it correctly flips the boolean flag for the selected index and handles boundary conditions (empty list).\n2. **Persistence Test**: Run the plugin, toggle a task with 'a', close the plugin, and inspect `tasks.json` to confirm the field is saved.\n3. **Visual Verification**: Launch the plugin, select a task, press 'a', and verify the agent icon/highlight appears. Press 'a' again to verify it disappears.",
        "status": "done",
        "dependencies": [
          "11",
          "14",
          "16"
        ],
        "priority": "high",
        "subtasks": [],
        "updatedAt": "2026-01-12T06:22:26.787Z",
        "activeAgent": false
      },
      {
        "id": "18",
        "title": "Implement Robust Error Handling (plugins/taskmaster)",
        "description": "Implement graceful error recovery for malformed JSON data and file I/O failures, adding a UI overlay to display errors without crashing the plugin.",
        "details": "This task focuses on preventing the plugin from panicking when encountering invalid states, particularly regarding the `tasks.json` data source. It involves updating the State model to hold error information and modifying the UI to render these errors.\n\n### Implementation Requirements\n\n1. **Update `State` Struct (`src/state.rs`)**:\n   - Add `pub error_msg: Option<String>` to the `State` struct.\n   - Implement helper methods: `set_error(msg: String)` and `clear_error()`.\n\n2. **Safe Data Loading (`src/plugin.rs`)**:\n   - Refactor the task loading logic (likely using `std::fs::read_to_string` and `serde_json::from_str`).\n   - Instead of `.unwrap()` or `.expect()`, use `match` or `if let Err(e)` patterns.\n   - On failure, capture the error message (e.g., \"JSON Syntax Error at line 10\") and call `state.set_error(...)` instead of panicking.\n\n3. **UI Error Overlay (`src/ui.rs`)**:\n   - Implement `draw_error_modal` function.\n   - Check `state.error_msg` at the beginning of the render loop. If present, render a centered box (using `Theme::error` color from Task #13) containing the message on top of the dashboard.\n   - Ensure the overlay obscures or dims the underlying content to indicate a modal state.\n\n4. **Input Handling (`src/plugin.rs`)**:\n   - In the `update` loop, if `state.error_msg` is `Some`, intercept input events.\n   - Map `Esc` or `Enter` to `state.clear_error()`, allowing the user to attempt a reload or return to a neutral state after fixing the external file.",
        "testStrategy": "1. **Malformed JSON Test**: Manually corrupt `tasks.json` (e.g., remove a closing brace) while the plugin is running (or before starting). Verify the plugin displays a red error box describing the syntax error instead of crashing.\n2. **Missing File Test**: Rename `tasks.json` to trigger an I/O error. Verify the error is caught and displayed.\n3. **Recovery Workflow**: While the error is displayed, fix `tasks.json` externally, then press `Esc`/`Enter` in the plugin. Verify the task list reloads correctly and the error message disappears.",
        "status": "done",
        "dependencies": [
          "13",
          "14"
        ],
        "priority": "medium",
        "subtasks": [],
        "updatedAt": "2026-01-12T06:22:40.810Z",
        "activeAgent": false
      },
      {
        "id": "19",
        "title": "Implement Optimistic UI Updates (plugins/taskmaster)",
        "description": "Decouple UI state updates from file persistence to ensure immediate visual feedback during user interactions like toggling status or assigning agents.",
        "details": "This task focuses on making the plugin feel responsive ('snappy') by modifying the in-memory state and re-rendering immediately upon user input, rather than waiting for file I/O completion or file-watcher events.\n\n### Implementation Requirements\n\n1. **Modify Event Loop (`src/main.rs`)**:\n   - Review the `update` function where key events (e.g., 'd' for done, 'a' for agent, 'p' for priority) are handled.\n   - Currently, these likely trigger a write operation immediately. Refactor this flow.\n   \n2. **Update `State` Logic (`src/state.rs`)**:\n   - Implement specific mutation methods on the `State` struct, e.g., `pub fn optimistic_update_status(&mut self, index: usize, status: TaskStatus)`.\n   - Ensure these methods update both the raw task list and the filtered view (referencing Task #16 logic) immediately.\n\n3. **Persistence Strategy**:\n   - After the in-memory mutation and render call, perform the blocking file I/O to save `tasks.json`.\n   - If the I/O operation fails, utilize the error handling mechanism from Task #18 (`state.set_error()`) to notify the user, and optionally revert the local state change by reloading from disk.\n\n4. **Visual Consistency**:\n   - Ensure that when the file watcher eventually triggers (if applicable), it does not cause a 'stutter' if the on-disk state matches the current optimistic in-memory state.",
        "testStrategy": "1. **Latency Test**: Temporarily inject a `std::thread::sleep` of 500ms into the file writing function. Run the plugin and press 'd'. Verify the checkmark appears *instantly*, before the sleep finishes.\n2. **Persistence Verification**: After the instant update, verify `tasks.json` is correctly updated on disk.\n3. **Filter Interaction**: Apply a filter (e.g., show only 'Pending'). Mark a task as 'Done'. Verify it disappears from the view immediately without requiring a manual refresh.",
        "status": "done",
        "dependencies": [
          "14",
          "16",
          "18"
        ],
        "priority": "low",
        "subtasks": [],
        "updatedAt": "2026-01-12T06:22:54.510Z",
        "activeAgent": false
      },
      {
        "id": "20",
        "title": "Fix Taskmaster plugin root selection for new AOC tabs",
        "description": "Ensure Taskmaster plugin reads project root from the shared root file instead of stale server env vars so new tabs load correctly.",
        "details": "Adjust plugin state loading to avoid locking root to AOC_PROJECT_ROOT/ZELLIJ_PROJECT_ROOT and prefer root_file when resolving root via command.",
        "testStrategy": "Rebuild the Taskmaster plugin and open a new AOC tab from an existing session; confirm tasks render in the Taskmaster pane and root matches the tab cwd.",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": [],
        "updatedAt": "2026-01-12T13:58:44.521Z",
        "activeAgent": false
      },
      {
        "id": "21",
        "title": "Validate and Refine Per-Tab Root Isolation for Multi-Project Workflows",
        "description": "Verify and harden the root isolation mechanism across aoc-launch, aoc-new-tab, aoc-align, and aoc-star to ensure concurrent Zellij tabs can operate on distinct projects without state leakage.",
        "details": "This task focuses on integration testing and refinement of the project root management strategy implemented in Task #20. The goal is to ensure that opening multiple AOC tabs (even in the same Zellij session) allows each tab to maintain a unique project context.\n\n### Analysis & Implementation Steps\n\n1.  **Review Shell Scripts (`bin/`)**:\n    -   Analyze `bin/aoc-launch` and `bin/aoc-new-tab`. Verify how `AOC_PROJECT_ROOT` is propagated to the new tab layout.\n    -   Ensure `aoc-new-tab` creates a unique context (e.g., by ensuring the `.root` file or environment variable is scoped to the tab or strictly passed via layout parameters).\n    -   Check `bin/aoc-align` (pane alignment) and `bin/aoc-star` (task creation) to ensure they respect the *current* tab's root, not a global variable.\n\n2.  **Verify Plugin Behavior (`plugins/taskmaster`)**:\n    -   The `taskmaster` plugin (Rust) reads a root path. Based on Task #20, it prioritizes a root file. Ensure this file lookup is tab-aware (e.g., checking the current working directory or a specific tab-local environment variable provided by Zellij) rather than reading a singleton global file if multiple tabs exist.\n    -   If the plugin relies on `ZELLIJ_SESSION_NAME` or strictly on `CWD`, confirm that `aoc-launch` starts the plugin in the correct directory.\n\n3.  **Refactor for Tab-Local State (if needed)**:\n    -   If `aoc-new-tab` currently overwrites a global `/tmp/aoc.root` file (implying a race condition between tabs), refactor it to pass the root directly into the Zellij layout template or set a tab-scoped environment variable if supported.\n    -   Alternatively, verify the plugin logic strictly prefers `std::env::current_dir()` as the source of truth when no explicit root argument is provided.\n\n4.  **Edge Case Handling**:\n    -   Test scenarios where a user navigates `cd ..` in a shell pane. Does `aoc-star` still pick up the original project root or the new directory? (Should likely stick to the project root defined at launch).",
        "testStrategy": "1. **Multi-Tab Setup**: Open a Zellij session. Use `aoc-launch` to start Project A in Tab 1. Use `aoc-new-tab` to start Project B in Tab 2.\n2. **Verification**:\n   - **Visual**: Confirm the Taskmaster pane in Tab 1 shows Project A tasks, and Tab 2 shows Project B tasks.\n   - **Action**: Run `aoc-star \"Task A\"` in Tab 1 and `aoc-star \"Task B\"` in Tab 2. Verify `Task A` appears only in Project A's `tasks.json` and `Task B` only in Project B's.\n3. **Cross-Pollination Check**: Switch back to Tab 1 and refresh. Ensure Project B data has not leaked into the view.\n4. **Tool Check**: Run `aoc-align` in both tabs to ensure panes resize correctly according to their specific layout context.",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": [],
        "updatedAt": "2026-01-17T17:23:11.961Z",
        "activeAgent": false
      },
      {
        "id": "22",
        "title": "Verify and Harden Idle Session Lifecycle Management (aoc-session-watch)",
        "description": "Implement and verify the `aoc-session-watch` utility to handle session detach events by renaming sessions to `idle-*`, pruning heavy UI processes, and restoring the full layout upon reattachment.",
        "details": "This task focuses on the lifecycle management of Zellij sessions to optimize resource usage when sessions are not in focus (detached). The `aoc-session-watch` script acts as a daemon or hook that monitors session state.\n\n### Implementation Requirements\n\n1.  **Create/Update `bin/aoc-session-watch`**:\n    -   **Detach Handler**: Detect when the current client detaches. Rename the session from `[name]` to `idle-[name]` using `zellij action rename-session`.\n    -   **Pruning Logic**: When entering 'idle' state, identify and terminate resource-heavy UI processes that are not essential for background agent work (e.g., `yazi`, `chafa`, `k9s`). **Crucially**, ensure the Agent process (LLM loop) and the Taskmaster plugin remain running.\n    -   **Reattach Handler**: When a client attaches to an `idle-[name]` session, rename it back to `[name]` (removing the prefix).\n    -   **Layout Restoration**: Upon reattach, verify if panes were closed or if the layout needs to be re-applied to restore the UI tools (e.g., respawning the file browser pane if it was killed).\n\n2.  **Integration with `aoc-launch`**:\n    -   Ensure `aoc-launch` starts `aoc-session-watch` in the background or as a daemon pane within the session.\n\n3.  **Safety Checks**:\n    -   Prevent renaming if the session is already active elsewhere (multi-client scenarios).\n    -   Ensure PID tracking logic is robust so it doesn't kill the wrong processes.",
        "testStrategy": "1. **Resource Monitoring**: Launch a session with a heavy process (e.g., `btm` or a mocked CPU spinner). Detach. Verify via `htop` outside the session that the process is terminated/suspended and the session is renamed to `idle-*`.\n2. **Agent Persistence**: Ensure a running mock agent script continues writing to logs/files while the session is idle.\n3. **Restoration**: Reattach to the session. Confirm the session name reverts. Verify that killed UI panes (like file explorer) are automatically respawned or the layout is reloaded correctly.",
        "status": "done",
        "dependencies": [
          "21"
        ],
        "priority": "medium",
        "subtasks": [],
        "updatedAt": "2026-01-17T17:40:07.296Z",
        "activeAgent": false
      },
      {
        "id": "23",
        "title": "Verify and Implement Tab-Close Process Cleanup in aoc-session-watch",
        "description": "Implement the `trim_closed_tab_processes` function in `aoc-session-watch` to detect closed Zellij tabs and terminate associated background processes (like file watchers or servers) to prevent resource leaks.",
        "details": "This task addresses the issue of orphaned processes remaining after an AOC tab is closed. The implementation should leverage `zellij action query-tab-names` and process tree analysis.\n\n### Implementation Requirements\n\n1.  **Enhance `bin/aoc-session-watch`**:\n    -   **State Tracking**: Maintain an in-memory list or temp file tracking active Tab IDs and their associated PIDs (if detectable via Zellij's layout info or by tagging processes during launch).\n    -   **Polling/Event Loop**: Regularly (e.g., every 2-5 seconds) query the current list of open tabs using `zellij action query-tab-names`.\n    -   **Diff Logic**: Compare the current list of tabs against the previous state.\n    -   **`trim_closed_tab_processes()` Implementation**:\n        -   Identify tabs that were present in the previous state but missing in the current state.\n        -   If a mechanism exists to map Tab ID -> PIDs (e.g., via `zellij action list-clients` or inspecting the pane tree), iterate through those PIDs.\n        -   Send `SIGTERM` to the identified process groups (`pgid`) to ensure child processes (like `npm run dev`) are also cleaned up.\n        -   *Note*: Since Zellij may not expose PIDs per tab directly in CLI, consider an approach where `aoc-launch` writes a PID file keyed by Tab ID (e.g., `/tmp/aoc/pids/<session>_<tab_id>.pid`) which `aoc-session-watch` reads and cleans up.\n\n2.  **PID Tracking Integration (Optional but likely needed)**:\n    -   Modify `bin/aoc-launch` or `bin/aoc-new-tab` to record the PID of the primary process launched in the tab into a registry directory.",
        "testStrategy": "1. **Orphan Test**: Launch a heavy process (e.g., `python3 -m http.server 9999`) in a new AOC tab. Note its PID via `ps aux | grep python`. Close the tab via Zellij keybinding (Ctrl+t, x). Wait 5 seconds. Verify the PID no longer exists in `ps aux`.\n2. **Registry Verification**: Check that the temporary PID tracking files are correctly created on tab open and deleted on tab close.\n3. **Multiple Tabs**: Open 3 tabs. Close the middle one. Ensure only the middle tab's processes are killed.",
        "status": "done",
        "dependencies": [
          "22"
        ],
        "priority": "medium",
        "subtasks": [],
        "updatedAt": "2026-01-17T17:47:05.092Z",
        "activeAgent": false
      },
      {
        "id": "24",
        "title": "Fix Taskmaster Plugin Scrollback Growth and Render Throttling",
        "description": "Implement state comparison logic to prevent redundant UI rendering and endless scrollback growth by ensuring the plugin only repaints when data or UI state actually changes.",
        "details": "This task addresses performance issues where the Taskmaster plugin may be re-rendering frames unnecessarily, causing high CPU usage or scrollback pollution. \n\n### Implementation Steps:\n1. **State Tracking (`src/state.rs`)**: \n   - Add a field to the `State` struct to track the signature of the last rendered frame (e.g., `last_render_signature: u64` or a clone of the relevant state subset).\n   - Implement a method `get_render_signature(&self)` that hashes or captures key UI state components: the tasks list (content and status), selected index, current filter mode, and any active error message.\n\n2. **Render Logic (`src/main.rs`)**:\n   - In the `render` method (or the main event loop handler), generate the signature for the current state.\n   - Compare the current signature with `state.last_render_signature`.\n   - If they match, return early without printing to stdout (printing ANSI codes to the terminal is what causes scrollback growth).\n   - If they differ, proceed with rendering and update `state.last_render_signature`.\n\n3. **Event Loop Optimization**:\n   - Review the `update` function. Ensure that events which do not affect visual state (e.g., file watcher ticks that result in identical data) do not trigger the `should_render` flag.\n   - Specifically, when reloading `tasks.json`, compare the new loaded data with the existing memory data. Only set `should_render = true` if the data differs.",
        "testStrategy": "1. **Idleness Verification**: Launch the plugin in Zellij. Do not interact with it. Monitor Zellij logs (or use `strace` on the plugin process if applicable) to verify the `render` function is not being called repeatedly in a loop while idle.\n2. **Interaction Verification**: Move the cursor and mark tasks as done. Verify the UI updates immediately (preserving the functionality from Task #19).\n3. **Redundant Data Test**: Manually `touch .taskmaster/tasks/tasks.json` without changing content. Verify visually that the screen does not flicker or reprint unnecessarily.",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": [],
        "updatedAt": "2026-01-17T17:30:50.862Z",
        "activeAgent": false
      },
      {
        "id": "25",
        "title": "Fix Tmux Cleanup Configuration for Agent Panes",
        "description": "Configure tmux sessions for agent tools (opencode, codex) with 'destroy-unattached' and 'exit-empty' to ensure servers terminate automatically when the parent Zellij pane or tab is closed.",
        "details": "This task addresses resource leaks where tmux servers spawned by agent scripts remain active after the UI pane is closed. The implementation involves modifying the tmux startup commands in the agent wrapper scripts.\n\n### Implementation Steps\n\n1.  **Analyze Agent Launch Scripts**:\n    -   Locate scripts in `bin/` or `agents/` that invoke `tmux`. Likely candidates include `bin/opencode` or similar wrappers.\n    -   Identify the `tmux new-session` command lines.\n\n2.  **Apply Configuration Flags**:\n    -   Update the tmux invocation to include specific server configuration options via the `-f` config file argument or by passing configuration commands with `set-option`.\n    -   Ensure `set-option -g destroy-unattached on` is applied. This ensures the session is killed when no clients are attached (i.e., when the Zellij pane hosting the client closes).\n    -   Ensure `set-option -g exit-empty on` is applied (default behavior, but explicit setting prevents regressions).\n\n3.  **Refine Socket Handling**:\n    -   If the agents use named sockets (`-S /tmp/tmux-agent-socket`), ensure the cleanup logic or the socket location allows for automatic removal, or verify that `destroy-unattached` handles the socket cleanup correctly.\n\n4.  **Example Modification**:\n    ```bash\n    # Before\n    tmux -S \"$SOCKET\" new-session -s \"$SESSION_NAME\" -d\n    \n    # After\n    tmux -S \"$SOCKET\" new-session -s \"$SESSION_NAME\" -d\n    tmux -S \"$SOCKET\" set-option -g destroy-unattached on\n    tmux -S \"$SOCKET\" set-option -g exit-empty on\n    ```\n\n5.  **Integration with AOC Lifecycle**:\n    -   Review interaction with `aoc-session-watch` (Task #22) to ensure these settings don't conflict with intended idle states, though agent panes usually should die if the UI is gone.",
        "testStrategy": "1. **Orphan Check**: Open an agent pane (e.g., run `opencode`). Verify the tmux server process exists (`ps aux | grep tmux`). Close the Zellij pane containing the agent. Verify the tmux process terminates immediately.\n2. **Re-attach Test**: Launch the agent, detach the Zellij session, and re-attach. Ensure the agent tmux session persists (since the client detached but the session wasn't destroyed/closed, just hidden). Close the tab completely and verify termination.",
        "status": "done",
        "dependencies": [
          "23"
        ],
        "priority": "low",
        "subtasks": [],
        "updatedAt": "2026-01-17T17:52:39.738Z",
        "activeAgent": false
      },
      {
        "id": "26",
        "title": "Enhance Yazi with Status Bar Tips and Pane Resize on File Open",
        "description": "Add Zellij-style command tips to Yazi status bar and implement automatic pane expansion when opening files for better visibility.",
        "details": "This task improves the Yazi file manager UX within AOC by:\\n\\n1. **Status Bar Tips**: Added `init.lua` that displays command hints at the bottom of the Yazi status bar (matching Zellij's status bar style with Catppuccin colors).\\n2. **Pane Resize Plugin**: Created `aoc-open.yazi` plugin that expands the Yazi pane to ~40% when opening a file, allowing users to see the file content clearly while keeping other AOC panes visible.\\n3. **Theme Styling**: Added `theme.toml` with Catppuccin-inspired colors for file types.\\n4. **Keybindings**: Updated `keymap.toml` with Enter override for open+resize, and `e` for direct edit.\\n\\n### Files Created/Modified:\\n- `yazi/init.lua` - Status bar command tips\\n- `yazi/theme.toml` - File type colors\\n- `yazi/keymap.toml` - Updated keybindings\\n- `yazi/plugins/aoc-open.yazi/main.lua` - Resize on open plugin\\n- `install.sh` - Updated to install new files\\n- `README.md` - Documentation added",
        "testStrategy": "1. Run `./install.sh` to deploy the new config files.\\n2. Launch AOC and verify Yazi status bar shows command tips at the bottom.\\n3. Press Enter on a file and confirm the Yazi pane expands.\\n4. Press `e` to edit a file and confirm it opens in $EDITOR.",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": [],
        "updatedAt": "2026-01-17T18:00:00.000Z",
        "activeAgent": false
      },
      {
        "id": "27",
        "title": "Refactor Context System to .aoc/ and Universal Agent Injection",
        "description": "Migrate the project configuration directory from .gemini/ to .aoc/ and implement a standardized mechanism to inject project context into any AI agent session.",
        "details": "This task unifies the context management system, moving away from provider-specific naming (.gemini) to a generic project directory (.aoc). It also standardizes how context is loaded and injected.\n\n### Implementation Requirements\n\n1. **Directory Migration & Install Logic**:\n   - Update `install.sh` and `bin/` scripts to use `$HOME/.aoc` (or project-local `.aoc/`) instead of `.gemini/`.\n   - Implement a migration check: If `.gemini/` exists and `.aoc/` does not, move/rename it automatically.\n   - Update `.gitignore` to exclude `.aoc/`.\n\n2. **Context Structure Definition**:\n   - Standardize the `.aoc/` structure:\n     - `config.json`: Global settings (API keys references, preferred model).\n     - `system/`: System prompts.\n     - `project/`: Project-specific context files (architecture, patterns).\n\n3. **Universal Injection Utility**:\n   - Create or refactor a utility (e.g., `bin/aoc-context` or a Rust module `src/context.rs`) that aggregates files from `.aoc/project/` and `.aoc/system/` into a single context payload.\n   - Ensure this payload can be piped into different agent backends (Gemini, local LLMs, etc.).\n\n4. **Taskmaster Integration**:\n   - Update `plugins/taskmaster/src/state.rs` or `model.rs` to read configuration and context paths from the new `.aoc/` location.\n   - Ensure the 'Assign to Agent' feature (Task 17) pulls the correct system prompt from this new location.",
        "testStrategy": "1. **Migration Verification**: Create a dummy `.gemini` folder, run the updated setup/install script, and verify it is renamed to `.aoc`.\n2. **Context Aggregation**: Populate `.aoc/project/` with two Markdown files. Run the injection utility and verify the output contains the text from both files.\n3. **Plugin Integration**: Launch the Taskmaster plugin. Verify it starts without errors (locating the new config) and that agent actions successfully retrieve the context.",
        "status": "done",
        "dependencies": [
          "6",
          "11",
          "17",
          "18"
        ],
        "priority": "high",
        "subtasks": [],
        "updatedAt": "2026-01-17T19:53:49.855Z",
        "activeAgent": false
      },
      {
        "id": "28",
        "title": "Implement RLM (Recursive Language Model) Skill for AOC",
        "description": "Create a new RLM skill module that enables recursive task decomposition and execution using LLM interactions within the Agent Ops Cockpit.",
        "details": "This task focuses on integrating a Recursive Language Model (RLM) capability into the AOC backend. This skill allows the system to take a high-level goal, break it down into sub-tasks using an LLM, and recursively execute or refine those sub-tasks.\n\n### Implementation Requirements\n\n1.  **Create Skill Module (`src/skills/rlm.rs`)**:\n    -   Define an `RlmSkill` struct implementing the `Skill` trait (if one exists, otherwise define a standard interface with `execute` and `help` methods).\n    -   Implement the `execute` method to accept a prompt/goal string.\n\n2.  **LLM Integration**:\n    -   Integrate with an LLM provider (e.g., via `reqwest` to OpenAI API or a local endpoint like Ollama). Use environment variables for API keys/endpoints.\n    -   Design a system prompt that instructs the LLM to output a JSON structure representing the breakdown of the task (e.g., `[{ \"step\": 1, \"description\": \"...\" }, ...]`).\n\n3.  **Recursive Logic**:\n    -   Implement the logic to parse the LLM's response.\n    -   For each sub-task identified, create a new `Task` entry in the system (leveraging the existing Task model).\n    -   If a sub-task is complex (based on complexity heuristics or LLM flagging), recursively call the RLM logic on that specific sub-task (up to a defined `MAX_DEPTH`).\n\n4.  **Integration with Taskmaster**:\n    -   Ensure generated tasks are persisted to `tasks.json` so they appear in the UI.\n    -   Add a command or keybinding (e.g., in `plugins/taskmaster`) to trigger this skill on the currently selected task.",
        "testStrategy": "1. **Mocked LLM Test**: Create a unit test for `RlmSkill` using a mocked HTTP client. Verify that a sample JSON response from the 'LLM' is correctly parsed into a list of `Task` objects.\n2. **Recursion Depth Test**: Verify that the recursion logic respects the `MAX_DEPTH` constant to prevent infinite loops.\n3. **End-to-End Flow**: Trigger the RLM skill on a generic task like 'Plan a party' via the UI/CLI. Check `tasks.json` to ensure valid subtasks (e.g., 'Buy food', 'Invite guests') are created and linked to the parent task.",
        "status": "cancelled",
        "dependencies": [
          "18",
          "19",
          "15"
        ],
        "priority": "high",
        "subtasks": [],
        "updatedAt": "2026-01-17T20:24:33.386Z",
        "activeAgent": false
      },
      {
        "id": "29",
        "title": "Implement RLM CLI Tool and Protocol (bin/aoc-rlm)",
        "description": "Develop the standalone `aoc-rlm` binary for recursive task decomposition, update initialization templates, and document the IPC protocol.",
        "details": "This task creates the external executable responsible for the heavy lifting of the Recursive Language Model (RLM) skill. \n\n### Implementation Requirements\n\n1. **Create `bin/aoc-rlm`**:\n   - Initialize a new Rust binary crate within the workspace.\n   - Implement argument parsing using `clap` (arguments: `--goal`, `--context`, `--depth`, `--model`).\n   - **LLM Client**: Implement `src/llm.rs` using `reqwest` to interface with OpenAI/Anthropic APIs. It must handle prompt construction for recursive decomposition.\n   - **Recursion Logic**: Implement `src/engine.rs` to process the goal, receive LLM response, parsing the JSON list of steps. If current depth < max depth, recursively process complex steps.\n\n2. **Protocol Definition**:\n   - Create `docs/RLM_PROTOCOL.md` defining the JSON schema for Input (Goal/Context) and Output (Task Tree).\n   - Output format must align with the `Task` struct structure used in `plugins/taskmaster` (Task 15).\n\n3. **Update `aoc-init`**:\n   - Modify `bin/aoc-init` (or relevant init script) to generate a default `.aoc-rlm-config.toml` in new projects, specifying default models and depth limits.",
        "testStrategy": "1. **CLI Mock Test**: Run `cargo run --bin aoc-rlm -- --goal 'Test' --dry-run` to verify argument parsing and configuration loading without hitting the LLM.\n2. **Protocol Compliance**: Feed a sample JSON input to the binary and validate that the output JSON strictly matches the schema required by the Taskmaster plugin (Task 15).\n3. **Recursion Limit Test**: configure max depth to 1, provide a complex goal, and ensure the output contains flat steps without further nested recursion.",
        "status": "done",
        "dependencies": [
          "28",
          "15",
          "18"
        ],
        "priority": "high",
        "subtasks": [],
        "updatedAt": "2026-01-17T20:23:36.342Z",
        "activeAgent": false
      },
      {
        "id": "30",
        "title": "Implement Reactive Context Watcher Service",
        "description": "Create a background service that monitors file system changes and automatically regenerates `context.md` to ensure the AI agent always possesses up-to-date project context.",
        "details": "This task involves creating a new binary or extending an existing one to watch for file changes in the project root and update a centralized context file. \n\n### Implementation Requirements\n\n1. **Service Architecture**:\n   - Implement as a subcommand in `aoc-session-watch` or a new binary `bin/aoc-context-watcher`.\n   - Use the `notify` crate for cross-platform file system monitoring.\n   - **Configuration**: Support a `.contextignore` file (or respect `.gitignore`) to prevent irrelevant updates (e.g., `target/`, `.git/`, `node_modules/`).\n\n2. **Context Generation Logic**:\n   - Create a module `src/context_gen.rs`.\n   - Implement `generate_context_file(root: &Path, output: &Path)`.\n   - This function should traverse the project, collect file structures (using `walkdir`), and aggregate specific file contents (e.g., `README.md`, `src/main.rs`, `Cargo.toml`).\n   - **Debouncing**: Implement a debounce mechanism (e.g., 500ms-2s) to prevent thrashing during rapid file edits (using `tokio::time` or a dedicated debounce channel).\n\n3. **Integration**:\n   - Ensure the service runs in the background, perhaps managed by the same process lifecycle as `aoc-session-watch`.\n   - Write the output to a designated location like `.aoc/context.md` or root `context.md`.\n\n4. **Performance Optimization**:\n   - Limit the size of included files (e.g., skip files > 100KB).\n   - Only rebuild the sections that changed if possible, or do a full rebuild if simplicity is preferred for V1.",
        "testStrategy": "1. **Watcher Test**: Run the service, modify a monitored file (e.g., `src/main.rs`), and verify that the `context.md` file's modification timestamp updates within the debounce window.\n2. **Content Verification**: Add a dummy file `test_context_gen.txt`, wait for update, and grep `context.md` to ensure the new file's content is present.\n3. **Ignore Logic**: Modify a file in `target/` and verify `context.md` is NOT updated.\n4. **Debounce Check**: Save a file 5 times in 1 second; verify `context.md` is updated only once at the end.",
        "status": "done",
        "dependencies": [
          "23"
        ],
        "priority": "high",
        "subtasks": [],
        "updatedAt": "2026-01-18T10:13:23.237Z",
        "activeAgent": false
      },
      {
        "id": "31",
        "title": "Refactor Agent Attribution to Support Multi-Agent Identification",
        "description": "Replace the binary attribution flag in the Task model with an optional Agent ID to distinguish between specific agents and user actions.",
        "details": "The current `Task` model uses a boolean (likely `is_agent`) to denote automated tasks, limiting the system to a single implied agent source. This refactor introduces precise attribution.\n\n### Implementation Requirements\n\n1. **Model Refactor (`plugins/taskmaster/src/model.rs`)**:\n   - Update the `Task` struct definition.\n   - Replace the `is_agent` boolean field with `agent_id: Option<String>` (or a custom `AgentId` type).\n   - Implement `serde` attributes or a custom deserializer to ensure backward compatibility: `is_agent: true` in existing JSON should map to `agent_id: Some(\"generic_agent\".into())`.\n\n2. **UI Enhancements (`plugins/taskmaster/src/ui.rs`)**:\n   - Update the render loop to check `agent_id.is_some()` for automated task styling.\n   - Display the specific Agent ID (e.g., \"RLM\", \"Planner\") in the task detail view or as a badge in the list view if space permits.\n\n3. **Integration**:\n   - Ensure `src/state.rs` preserves this new field during task updates.\n   - Update any internal task creation logic to allow passing an Agent ID.",
        "testStrategy": "1. **Migration Unit Test**: Create a test case with a JSON string matching the old schema (`{\"is_agent\": true}`) and assert it deserializes into `agent_id: Some(...)`.\n2. **Round-Trip Test**: Verify that saving and loading the new structure preserves the specific Agent ID strings.\n3. **Visual Verification**: Manually inject a task with `agent_id: \"RLM\"` into the data file and verify the UI distinguishes it from user tasks.",
        "status": "pending",
        "dependencies": [
          "11"
        ],
        "priority": "medium",
        "subtasks": [],
        "updatedAt": null,
        "activeAgent": false
      },
      {
        "id": "32",
        "title": "Implement aoc-doctor Version Validation",
        "description": "Enhance the aoc-doctor utility to validate installed tool versions against defined requirements, reporting mismatches or missing dependencies.",
        "details": "This task focuses on implementing the core logic for `aoc-doctor` to parse a requirements file (e.g., `.tool-versions` or a section in `package.json`/`Cargo.toml`) and compare current system versions against these constraints.\n\n### Implementation Requirements\n\n1.  **Define Requirements Schema**:\n    -   Create a struct `ToolRequirement` with fields: `name` (String), `command` (String), `version_args` (Vec<String>), `version_regex` (String), and `required_version` (String/SemVer).\n    -   Decide on a configuration source (embedded default list + optional `aoc-tools.json` in project root).\n\n2.  **Implement Version Extraction**:\n    -   Create a function `get_tool_version(cmd: &str, args: &[&str]) -> Result<String>` using `std::process::Command`.\n    -   Implement regex matching to extract clean version numbers from output strings (e.g., capturing `1.70.0` from `cargo 1.70.0 (ec8...`).\n\n3.  **Implement SemVer Comparison**:\n    -   Utilize the `semver` crate to parse both the extracted version and the required version string.\n    -   Implement logic to determine if the installed version satisfies the requirement (e.g., `>=`).\n\n4.  **CLI Output Formatting**:\n    -   Update `bin/aoc-doctor` to output a checklist.\n    -   Use green checkmarks for pass, red crosses for fail/missing.\n    -   Example output: `[‚úì] cargo (1.75.0 >= 1.70.0)`.\n\n### targeted Tools\n-   `cargo`, `node`, `npm`, `zellij`.",
        "testStrategy": "1. **Mock Command Test**: Create unit tests that mock `Command` output to simulate various version strings (standard, non-standard, missing command) and verify the regex extraction logic.\n2. **SemVer Logic Test**: specific unit tests for the comparison logic (e.g., ensure 1.2.0 fails if requirement is >=1.3.0).\n3. **Integration Run**: Run `aoc-doctor` locally and verify it correctly identifies the versions of Cargo and Node installed on the dev machine.",
        "status": "pending",
        "dependencies": [
          "18",
          "30"
        ],
        "priority": "medium",
        "subtasks": [],
        "updatedAt": null,
        "activeAgent": false
      },
      {
        "id": "33",
        "title": "Implement Live Context Handshake for Long-Running Sessions",
        "description": "Develop a mechanism to detect context staleness in active agent sessions and implement a re-handshake protocol to inject updated context without restarting the session.",
        "details": "This task addresses the architectural gap where long-running agent sessions rely on context loaded at startup, leading to hallucinations or errors when the underlying project state changes. \n\n### Implementation Requirements\n\n1. **Context Hash/Version Tracking**:\n   - Enhance `aoc-context-watcher` (Task #30) to maintain a hash or timestamp of the aggregated `context.md`.\n   - Expose this version identifier via a lightweight local endpoint or file (e.g., `.aoc/context.version`).\n\n2. **Staleness Detection Middleware**:\n   - In the agent interaction loop (likely within `aoc-client` or the main session handler), check the current context version before every Nth prompt or after a set time interval.\n   - Compare the session's loaded context version with the live version from the file system.\n\n3. **Re-Handshake Protocol**:\n   - If staleness is detected, trigger a 'Soft Reset' or 'Context Refresh' flow.\n   - Construct a system prompt injection: \"[SYSTEM NOTICE: Project Context Updated. Discard previous file state assumptions. New context loaded below.]\".\n   - Append the new content of `.aoc/context.md` to the conversation history or replace the system prompt if the LLM provider API supports it (e.g., updating the system message in the chat array).\n\n4. **Configuration**:\n   - Add `auto_refresh_context: boolean` to the agent configuration.\n   - Add `refresh_interval_seconds: number` to control check frequency.",
        "testStrategy": "1. **Staleness Trigger Test**: Start a mock long-running session. Modify a file in the project. assert that the next agent interaction triggers a context reload log/event.\n2. **Injection Verification**: Inspect the conversation logs to ensure the updated context text is actually sent to the LLM in the subsequent request.\n3. **Stability Test**: Ensure the re-handshake doesn't confuse the agent or wipe out the conversation memory (history of *actions* should remain, only *project state* knowledge updates).",
        "status": "pending",
        "dependencies": [
          "27",
          "30"
        ],
        "priority": "low",
        "subtasks": [],
        "updatedAt": null,
        "activeAgent": false
      },
      {
        "id": "34",
        "title": "Harden and Expand Yazi Preview Script",
        "description": "Refactor the Yazi previewer to support rich media, robust fallback mechanisms, and enhanced syntax highlighting for the Agent Ops Cockpit file manager.",
        "details": "This task involves rewriting or significantly upgrading `yazi/preview.sh` to handle the diverse file types encountered in agent operations, utilizing the toolchain verified by `aoc-doctor`.\n\n### Implementation Requirements\n\n1.  **Robust Dispatcher Logic**:\n    -   Replace simple extension checks with `file --mime-type` detection for accuracy.\n    -   Implement a `has_command` utility function to check for tool availability before execution, allowing graceful degradation (e.g., if `chafa` is missing, fall back to `file` info).\n\n2.  **Expanded Format Support**:\n    -   **Images**: Optimize `chafa` arguments (`--symbols block --size ...`) for clearer terminal graphics.\n    -   **PDFs**: Implement previewing using `pdftoppm -jpeg -f 1 -singlefile` (from `poppler-utils`) piped to `chafa` for first-page rendering.\n    -   **Media**: Use `ffmpeg` to extract a thumbnail frame for videos, and `ffprobe` to display metadata for audio files.\n    -   **Structured Data**: Use `jq` for colored `.json` output and `column -t -s,` for readable `.csv` rendering.\n    -   **Archives**: Use `bsdtar`, `unzip`, or `7z` list modes to display the contents of archive files.\n\n3.  **Code & Text**:\n    -   Integrate `bat` with forced color output (`--color=always --style=plain`) for syntax highlighting, ensuring compatibility with Yazi's escape sequence handling.\n\n4.  **Performance & Safety**:\n    -   Add `timeout` logic to prevent preview generators from hanging the UI on corrupted or massive files.\n    -   Ensure the script passes the shellcheck workflow established in Task #8.",
        "testStrategy": "1. **Asset Matrix Validation**: Create a `tests/fixtures/previews` directory containing sample files for every supported type (valid JSON, invalid JSON, PDF, MP4, PNG, CSV, varying encodings).\n2. **Dry Run Verification**: Execute the script manually from the terminal: `./yazi/preview.sh path/to/fixture 10 10 100 100` (simulating geometry arguments) and assert standard output contains expected ANSI codes or graphic data.\n3. **Degradation Test**: Temporarily uninstall or mask binary dependencies (e.g., `alias chafa=false`) and verify the script falls back to text metadata or generic icons without crashing.",
        "status": "done",
        "dependencies": [
          "1",
          "8"
        ],
        "priority": "medium",
        "subtasks": [],
        "updatedAt": "2026-01-18T10:59:03.577Z",
        "activeAgent": false
      },
      {
        "id": "35",
        "title": "Polish Yazi Interface and Keybindings",
        "description": "Refine the Yazi file manager configuration to fix status bar labeling, improve the smart status line logic, and enhance pane resizing behavior for better workflow integration.",
        "details": "This task builds upon the initial Yazi enhancements (Task #26) to address visual inconsistencies and logic refinements. The goal is to ensure the custom status bar correctly displays labels and that the automated pane resizing logic is robust.\n\n### Implementation Requirements\n\n1.  **Fix Status Bar Labels (`yazi/init.lua`)**:\n    -   Review the custom status line implementation (Header:children). Currently, the 'Help' label is hardcoded or misaligned.\n    -   Update the status bar widget to dynamically reflect available keybindings or fix static labels to match the actual keymap (e.g., ensure 'Open', 'Select', 'Exit' labels are accurate).\n    -   Ensure the background and foreground colors of the labels transition smoothly without visual artifacts.\n\n2.  **Refine Smart Status Logic**:\n    -   Modify the status bar to show contextual information relevant to the AOC workflow (e.g., current git branch if possible, or specialized file info).\n    -   Ensure the status bar layout respects the `1:4:3` column ratio set in `yazi.toml` and doesn't overlap with the preview pane borders.\n\n3.  **Enhance Resize Logic (`plugins/aoc-open.yazi`)**:\n    -   The current resize logic (expanding to ~40%) might conflict with Zellij's own layout management or cause flickering.\n    -   Investigate utilizing `zellij action resize` commands more effectively within the Lua wrapper if possible, or adjust the resize step to be smoother.\n    -   Add logic to revert the resize (restore layout) when Yazi loses focus or when the file is closed, if not already handled.\n\n4.  **Keybinding & Config Polish**:\n    -   Finalize `yazi/keymap.toml` to ensure `g a` (.aoc), `g l` (logs), and `g c` (config) shortcuts work as intended.\n    -   Verify `Ctrl+t` behavior for task switching integration.\n    -   Ensure `yazi/theme.toml` colors are fully aligned with the Catppuccin/AOC palette used in Task #26.",
        "testStrategy": "1. **UI Verification**: Launch Yazi and inspect the status bar. Confirm that labels like 'Help', 'Open', etc., are correctly positioned and colored.\n2. **Resize Test**: Open a file from Yazi. Verify the pane expands. Close the file or switch focus and verify behavior is consistent/predictable.\n3. **Keybinding Check**: Test `g a` to jump to `.aoc/`. Test `Ctrl+t` functionality.",
        "status": "done",
        "dependencies": [
          "34",
          "26"
        ],
        "priority": "low",
        "subtasks": [
          {
            "id": 1,
            "title": "Fix Status Bar Labels in init.lua",
            "description": "Refactor the Header:children method in yazi/init.lua to correctly display 'Help', 'Open', 'Select', and 'Exit' labels with proper alignment and color transitions.",
            "status": "pending",
            "dependencies": []
          },
          {
            "id": 2,
            "title": "Implement Contextual Smart Status",
            "description": "Update the status bar to display contextual info such as Git branch or file metadata, respecting the column layout.",
            "status": "pending",
            "dependencies": [
              "1"
            ]
          },
          {
            "id": 3,
            "title": "Enhance Pane Resize Logic in aoc-open plugin",
            "description": "Optimize the resize behavior in plugins/aoc-open.yazi to handle Zellij interactions smoothly and restore layout on exit.",
            "status": "pending",
            "dependencies": []
          },
          {
            "id": 4,
            "title": "Finalize Keybindings and Theme Polish",
            "description": "Configure yazi/keymap.toml for 'g a', 'g l', 'g c' and Ctrl+t, and sync colors in yazi/theme.toml.",
            "status": "pending",
            "dependencies": []
          }
        ],
        "updatedAt": "2026-01-18T11:13:22.886Z",
        "activeAgent": false
      },
      {
        "id": "36",
        "title": "Initialize aoc-core Crate and Shared Data Models",
        "description": "Establish the shared Rust library `aoc-core` and implement standardized data structures for Task, Memory, and Context to unify types across the system.",
        "details": "This task creates the foundational library for the Rust migration, centralizing data definitions currently scattered across plugins and scripts.\n\n### Implementation Requirements\n\n1.  **Workspace Setup**:\n    -   Create a `crates/` directory in the project root.\n    -   Initialize a new library: `cargo new --lib crates/aoc-core`.\n    -   Update the root `Cargo.toml` (if it exists as a workspace) or create one to include `crates/aoc-core` as a member.\n\n2.  **Dependencies**:\n    -   Add `serde` (with derive), `serde_json`, and `chrono` (with serde) to `crates/aoc-core/Cargo.toml`.\n\n3.  **Implement Data Models**:\n    -   **`src/task.rs`**: Define `Task` struct mirroring the schema used in `tasks.json` (ref Task #18). Fields: `id` (u32/usize), `title` (String), `description` (String), `status` (Enum: Pending, InProgress, Done, Cancelled), `priority` (Enum), `dependencies` (Vec<u32>), `created_at` (DateTime<Utc>).\n    -   **`src/context.rs`**: Define `Context` struct to formalize the data generated by the Context Watcher (ref Task #30). Fields: `file_path` (PathBuf), `last_updated` (DateTime<Utc>), `content_hash` (String), `raw_content` (String).\n    -   **`src/memory.rs`**: Define `Memory` and `MemoryEntry` structs to support future agent interactions. Fields: `role` (String), `content` (String), `timestamp` (DateTime<Utc>).\n\n4.  **Exports**:\n    -   Ensure these modules are public in `lib.rs`.",
        "testStrategy": "1. **Serialization Round-trip**: Create a unit test in `src/task.rs` that instantiates a `Task`, serializes it to JSON, and asserts the string matches the expected format used by the Taskmaster plugin.\n2. **Schema Compatibility**: Copy a real entry from `tasks.json` into a test string and verify `serde_json::from_str::<Task>` deserializes it correctly without error.",
        "status": "done",
        "dependencies": [
          "18",
          "30"
        ],
        "priority": "high",
        "subtasks": [],
        "updatedAt": "2026-01-21T19:41:32.370Z",
        "activeAgent": false
      },
      {
        "id": "37",
        "title": "Implement aoc-cli Binary with Task and Mem Subcommands",
        "description": "Develop a unified Rust CLI tool in `crates/aoc-cli` that consumes `aoc-core` to replace legacy shell scripts for task and memory management.",
        "details": "This task involves creating the primary user-facing binary for the Agent Ops Cockpit, centralizing logic currently scattered across shell scripts.\n\n### Implementation Requirements\n\n1.  **Crate Initialization**:\n    -   Create `crates/aoc-cli`.\n    -   Update workspace `Cargo.toml`.\n    -   Add dependencies: `clap` (with `derive`), `anyhow`, `serde`, `serde_json`, and the local `aoc-core` crate.\n\n2.  **CLI Architecture (`src/main.rs`)**:\n    -   Use `clap::Parser` to define the entry point.\n    -   Create an enum `SubCommand` with variants `Task` and `Mem`.\n\n3.  **Task Subcommand (`src/commands/task.rs`)**:\n    -   Implement generic task operations utilizing `aoc_core::Task` models.\n    -   **actions**: `list` (display table), `add <title>` (append to tasks.json), `done <id>` (toggle status).\n    -   Ensure IO parity with existing `plugins/taskmaster` logic regarding `tasks.json` locking/writing.\n\n4.  **Mem Subcommand (`src/commands/mem.rs`)**:\n    -   Implement interactions with the memory/context system using `aoc_core::Memory` models.\n    -   **actions**: `add <content>` (append to memory bank), `search <query>` (grep/filter functionality).\n\n5.  **Integration**:\n    -   Ensure the binary reads configuration (paths to tasks.json) from the environment or default locations consistent with the project root.",
        "testStrategy": "1. **Clap Argument Verification**: specific unit tests to ensure `aoc-cli task add 'foo'` and `aoc-cli mem add 'bar'` parse arguments correctly.\n2. **Integration Test**: Create a temporary directory with a dummy `tasks.json`. Run the compiled binary to add a task, then verify the file content using `serde_json` to ensure the structure matches `aoc-core` definitions.\n3. **Idempotency Check**: Verify that running `task list` does not modify the file.",
        "status": "done",
        "dependencies": [
          "36"
        ],
        "priority": "high",
        "subtasks": [],
        "updatedAt": "2026-01-21T19:47:55.887Z",
        "activeAgent": false
      },
      {
        "id": "38",
        "title": "Rewrite aoc-taskmaster Plugin with aoc-core and Ratatui",
        "description": "Refactor the Taskmaster Zellij plugin to utilize the shared aoc-core library for data models and implement a modernized TUI using Ratatui with mouse support and interactive tables.",
        "details": "This task involves a significant refactor of the existing `plugins/taskmaster` to align with the new workspace architecture and improve UX.\n\n### Implementation Requirements\n\n1.  **Dependency Updates**:\n    -   Modify `plugins/taskmaster/Cargo.toml` to add `aoc-core` (path: `../../crates/aoc-core`) and `ratatui` (latest version).\n    -   Remove redundant local data structures (e.g., `Task`, `Status`) and replace them with imports from `aoc_core::models`.\n\n2.  **Ratatui Integration**:\n    -   Implement a custom Backend or helper to render `ratatui` buffers to the Zellij plugin output (standard output/ANSI).\n    -   Create a `ui.rs` module that defines the layout constraints (header, main table, footer/help).\n\n3.  **Table Widget**:\n    -   Use `ratatui::widgets::Table` to display tasks.\n    -   **Columns**: ID, State (checkbox/icon), Priority (colored), Title.\n    -   Implement `TableState` management in the plugin state to handle row selection and persistent highlighting.\n\n4.  **Input Handling & Scrolling**:\n    -   Update the `update` loop to handle `Event::Mouse` in addition to `Event::Key`.\n    -   **Mouse**: Map `Mouse::ScrollUp`/`Down` to table selection movement. Map `Mouse::LeftClick` to selecting the row under the cursor (requires calculating row height/offset).\n    -   **Keyboard**: Maintain existing bindings (j/k, d, r) but route them through the new `TableState` logic.",
        "testStrategy": "1. **Compilation Check**: Verify the plugin compiles with the new `aoc-core` dependency and WASM target (`cargo build --target w32-wasi`).\n2. **Interactive UI Test**: Load the plugin in Zellij. Verify that:\n   - The task list renders as a formatted table.\n   - Scrolling via mouse wheel moves the selection highlight.\n   - Clicking a row selects it.\n   - Resizing the pane adjusts column widths dynamically.\n3. **Data Integrity**: Ensure tasks loaded from `tasks.json` via `aoc-core` display correctly (correct status icons and priority colors).",
        "status": "done",
        "dependencies": [
          "36"
        ],
        "priority": "high",
        "subtasks": [],
        "updatedAt": "2026-01-21T20:08:08.127Z",
        "activeAgent": false
      },
      {
        "id": "39",
        "title": "Integrate aoc Binary in Tooling and Upgrade Watcher to aoc-core",
        "description": "Update agent tool definitions and documentation to utilize the new Rust CLI, and refactor the context watcher service to directly consume the aoc-core library for performance.",
        "details": "This task bridges the gap between the legacy shell-script environment and the new Rust architecture by updating external interfaces and internal background services.\n\n### Implementation Requirements\n\n1. **Tool Definitions & Documentation**:\n   - Audit `AGENTS.md` and tool definition files (likely in `.aoc/tools/` or `prompts/`) for references to legacy scripts like `task_add.sh` or `mem_add.sh`.\n   - Replace these references with the new `aoc` CLI syntax (e.g., `aoc task add ...`).\n   - Ensure parameter mapping in JSON schemas aligns with `aoc-cli` arguments defined in Task #37.\n\n2. **Refactor `aoc-watcher`**:\n   - Modify `crates/aoc-watcher/Cargo.toml` (created in Task #30) to add `aoc-core` as a local dependency.\n   - Remove ad-hoc file reading/concatenation logic from the watcher.\n   - Import and utilize `aoc_core::context` (from Task #36) to handle file scanning, ignoring patterns (git/contextignore), and context aggregation.\n   - Ensure the watcher leverages `aoc-core`'s efficient string handling to reduce overhead during rapid file changes.",
        "testStrategy": "1. **Tool Invocation Verification**: Manually execute a tool definition command (simulating an agent) and verify the `aoc` binary receives the correct arguments and successfully modifies the state (e.g., adds a task).\n2. **Watcher Integration Loop**: Start the refactored watcher. Modify a file ignored by `.contextignore` (verify no update). Modify a valid source file. Verify `context.md` updates immediately and matches the format expected by `aoc-core` unit tests.",
        "status": "pending",
        "dependencies": [
          "30",
          "36",
          "37"
        ],
        "priority": "medium",
        "subtasks": [],
        "updatedAt": null,
        "activeAgent": false
      }
    ]
  }
}
