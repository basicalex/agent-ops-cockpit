# Teach Full Scan - 20260215T175757Z (UTC)

## Inputs Read (in requested order)
- `.aoc/context.md`
- `aoc-mem read`
- `aoc-stm read-current` (empty) then `aoc-stm read`
- `aoc-task list`
- `.taskmaster/docs/prd.txt` (template placeholder content)

## system mental model
Concept (plain English): this repo is an operations cockpit for terminal AI agents. The core loop is: launch a session, wrap each agent process, emit local telemetry, aggregate in a session hub, and render operations UIs (Pulse/Mission Control and Taskmaster).

How this repo implements it:
- Session launcher and process bootstrap happen in shell scripts (`bin/aoc-launch`, `bin/aoc-agent-run`, `bin/aoc-agent-wrap`).
- Agent runtime telemetry is produced in Rust wrapper runtime (`crates/aoc-agent-wrap-rs/src/main.rs`).
- Session-scoped transport and cache are implemented by hub components (`crates/aoc-hub-rs/src/main.rs`, `crates/aoc-hub-rs/src/pulse_uds.rs`).
- Shared wire contracts live in `crates/aoc-core/src/pulse_ipc.rs` and are documented in `docs/pulse-ipc-protocol.md`.
- Operator UIs consume this state in terminal TUIs (`crates/aoc-mission-control/src/main.rs`, `crates/aoc-taskmaster/src/main.rs`, `crates/aoc-control/src/main.rs`).

Tradeoffs and alternatives:
- Current design favors local, session-scoped reliability over cloud-managed control planes.
- Rust + shell split gives portability and fast iteration, but increases cross-language orchestration complexity.
- Alternative: consolidate bootstrap/launch orchestration into Rust to reduce script drift.

Verification and debugging steps:
- Start hub and check health: `aoc-hub` then `curl http://127.0.0.1:<derived-port>/health`.
- Confirm Pulse transport enablement via logs and env flag (`AOC_PULSE_VNEXT_ENABLED`) in `crates/aoc-hub-rs/src/main.rs`.
- Inspect runtime logs under `.aoc/logs/` and session state in `~/.local/state/aoc/`.

Confidence: high.

## subsystem map

### 1) ingestion/parsing/chunking
Concept: convert repository content into bounded pieces suitable for analysis.

Repo implementation (nearest match):
- Implemented as RLM utility scan/peek/chunk, not as document ingestion pipeline (`crates/aoc-cli/src/rlm.rs`).
- File collection prefers git-tracked + untracked lists and filters heavy dirs (`crates/aoc-cli/src/rlm.rs`).
- Chunking is character-window based with line-range metadata (`crates/aoc-cli/src/rlm.rs`).

Missing/unclear:
- No dedicated ingestion orchestrator code in this repo (`src/` absent in workspace root; no `IngestionOrchestrator` outside memory notes).
- Memory references mention Python ingestion components, but corresponding files are not present here (`.aoc/memory.md`).

Tradeoffs and alternatives:
- Current chunking is fast and deterministic for code browsing.
- It lacks semantic parse stages (extract/normalize/schema/provenance).
- Alternative: add explicit staged ingest pipeline crate/module if this repo intends RAG-style ingestion.

Verification/debug:
- `aoc-rlm scan`, `aoc-rlm peek "term"`, `aoc-rlm chunk --pattern "crates/**/*.rs"`.
- Validate skip behavior for `.git`, `target`, `.aoc` in `crates/aoc-cli/src/rlm.rs`.

Confidence: high (for current implementation), high (for missing dedicated pipeline).

### 2) indexing/embeddings/retrieval
Concept: semantic storage and lookup (vectors/embeddings) for relevance retrieval.

Repo implementation:
- Not implemented as semantic retrieval in current codebase.
- Existing "state indexing" is operational (agent/task/diff caches), not embedding retrieval (`crates/aoc-hub-rs/src/main.rs`, `crates/aoc-hub-rs/src/pulse_uds.rs`).

Missing/unclear:
- No vector store, embedding provider, or retrieval ranker modules found in Rust workspace.
- `.taskmaster/docs/prd.txt` is a generic template, so product-level retrieval requirements are currently unclear.

Tradeoffs and alternatives:
- Avoiding embeddings keeps runtime simple and fully local.
- But it limits deep semantic Q/A features.
- Alternative: optional retrieval service behind feature flag (similar rollout style used for Pulse vNext).

Verification/debug:
- Search terms `embedding`, `vector`, `retrieval` across `crates/**/*.rs` to validate absence.
- Confirm only transport/state caches exist in hub and mission-control.

Confidence: high.

### 3) deep agent orchestration + filesystem tools
Concept: run many agent CLIs safely, normalize identity, and provide file interaction utilities.

Repo implementation:
- Wrapper resolves agent binaries, session/pane identity, and launches Rust runtime wrapper (`bin/aoc-agent-wrap`).
- Runtime wrapper handles heartbeat, task/diff summaries, PTY tap parsing, and command response path (`crates/aoc-agent-wrap-rs/src/main.rs`).
- Session launch ensures hub and layout wiring (`bin/aoc-launch`).
- Filesystem convenience tools are thin OS-open wrappers (`bin/aoc-open-file`, `bin/aoc-open-explorer`) plus yazi shim (`bin/aoc-yazi`).

Tradeoffs and alternatives:
- Strong operational control with unified wrapper, but wrapper code path is large and multi-concern.
- Alternative: split wrapper into smaller crates (process, telemetry, command-control) to reduce coupling.

Verification/debug:
- Run an agent through wrapper and check emitted status lifecycle transitions in logs.
- Validate stop command round-trip via Pulse command/result path in `crates/aoc-agent-wrap-rs/src/main.rs`.
- Confirm file opener behavior on Linux/WSL/macOS through script branches.

Confidence: high.

### 4) API/state/queue
Concept: session-local message bus with bounded fanout, snapshots, deltas, and command routing.

Repo implementation:
- WebSocket hub endpoint and health route are in `crates/aoc-hub-rs/src/main.rs`.
- Pulse NDJSON UDS path provides topic filters, bounded queues, stale reaping, layout watcher, and command routing (`crates/aoc-hub-rs/src/pulse_uds.rs`).
- Shared envelope/types/decoder with oversized-frame protection and malformed-line recovery (`crates/aoc-core/src/pulse_ipc.rs`, `docs/pulse-ipc-protocol.md`).

Tradeoffs and alternatives:
- Bounded channels and slow-consumer drops protect hub liveness.
- Tradeoff is potential event loss under pressure.
- Alternative: per-subscriber replay window or durable ring buffers to reduce data loss for slow UIs.

Verification/debug:
- Toggle `AOC_PULSE_VNEXT_ENABLED` and observe startup branch behavior (`crates/aoc-hub-rs/src/main.rs`).
- Inspect `pulse_queue_drop`, `pulse_send_backpressure`, and `pulse_layout_watcher_health` events (`crates/aoc-hub-rs/src/pulse_uds.rs`).
- Validate command role checks and target session enforcement (`crates/aoc-hub-rs/src/pulse_uds.rs`).

Confidence: high.

### 5) frontend/observability/tests
Concept: operator-facing UI and confidence signals proving behavior.

Repo implementation:
- Frontend is terminal-first (Ratatui), not web frontend (`crates/aoc-mission-control/src/main.rs`, `crates/aoc-taskmaster/src/main.rs`, `crates/aoc-control/src/main.rs`).
- Observability contracts are documented in rollout doc (`docs/pulse-vnext-rollout.md`) and emitted from hub/wrapper code paths (`crates/aoc-hub-rs/src/pulse_uds.rs`, `crates/aoc-agent-wrap-rs/src/main.rs`).
- CI builds workspace and shellchecks scripts (`.github/workflows/ci.yml`, `scripts/lint.sh`).
- Tests are mostly in-file Rust unit tests in pulse and mission-control components (`crates/aoc-core/src/pulse_ipc.rs`, `crates/aoc-hub-rs/src/pulse_uds.rs`, `crates/aoc-agent-wrap-rs/src/main.rs`, `crates/aoc-mission-control/src/main.rs`).

Missing/unclear:
- No `frontend/` web app or Python `tests/` currently present despite older memory entries mentioning Streamlit/pytest (`.aoc/memory.md`).

Tradeoffs and alternatives:
- TUI-first keeps dependency footprint lower and matches terminal-native mission.
- But it narrows accessibility for browser-only workflows.
- Alternative: optional web observer panel consuming same Pulse envelopes.

Verification/debug:
- Run `cargo test --manifest-path crates/Cargo.toml`.
- Check CI parity with `.github/workflows/ci.yml` and `scripts/lint.sh`.
- Validate observability event presence by tailing component logs in `.aoc/logs/`.

Confidence: high.

## key files per subsystem
- Ingestion/parsing/chunking: `crates/aoc-cli/src/rlm.rs`
- Indexing/embeddings/retrieval (operational cache only): `crates/aoc-hub-rs/src/main.rs`, `crates/aoc-hub-rs/src/pulse_uds.rs`
- Deep agent orchestration + fs tools: `bin/aoc-agent-wrap`, `bin/aoc-agent-run`, `bin/aoc-launch`, `crates/aoc-agent-wrap-rs/src/main.rs`, `bin/aoc-open-file`, `bin/aoc-open-explorer`, `bin/aoc-yazi`
- API/state/queue: `crates/aoc-core/src/pulse_ipc.rs`, `crates/aoc-hub-rs/src/main.rs`, `crates/aoc-hub-rs/src/pulse_uds.rs`, `docs/pulse-ipc-protocol.md`
- Frontend/observability/tests: `crates/aoc-mission-control/src/main.rs`, `crates/aoc-taskmaster/src/main.rs`, `crates/aoc-control/src/main.rs`, `docs/pulse-vnext-rollout.md`, `.github/workflows/ci.yml`, `scripts/lint.sh`

## current status (done vs fragile/missing)
Done/solid:
- Pulse vNext transport contracts, queue safety rails, and command routing are implemented and documented.
- Session-scoped identity model and launch wrapper flow are implemented across scripts + Rust runtime.
- Terminal UI stack (Mission Control + Taskmaster + Control) is present with unit tests in key components.

Fragile/missing:
- Dedicated ingestion pipeline is missing in this repo (only RLM chunking exists).
- Semantic indexing/embeddings/retrieval are missing.
- Root PRD file is still a template placeholder (`.taskmaster/docs/prd.txt`), so system-level target scope is under-specified.
- Memory contains entries for components not present in this checkout, indicating context drift risk (`.aoc/memory.md`).

## top risks
- Context drift risk: historical memory references non-present Python subsystems, which can mislead implementation planning.
- Product intent ambiguity: placeholder PRD weakens prioritization between operations cockpit work vs. retrieval/ingestion ambitions.
- Wrapper complexity concentration: orchestration, telemetry, and command handling are tightly coupled in one large runtime file.
- Event loss under pressure: queue-drop strategy protects hub health but can hide transient operational state in busy sessions.
- Testing shape risk: strong unit coverage in several crates, but limited explicit integration/e2e validation across launch->hub->wrapper->UI lifecycle.
